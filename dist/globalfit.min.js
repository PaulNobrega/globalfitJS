!function(e){"use strict";function r(e){const r=e.map((e=>[...e])),t=r.length;if(0===t)return{u:[],s:[],v:[]};const n=r[0].length;if(0===n)return{u:r.map((()=>[])),s:[],v:[]};t<n&&console.warn("svdDecompose warning: Implementation assumes m >= n. Results may be incorrect.");const a=new Array(n).fill(0),i=Array.from({length:n},(()=>new Array(n).fill(0))),o=new Array(n).fill(0);let l=0,s=0,c=0;for(let e=0;e<n;e++){s=0;for(let n=e;n<t;n++)s+=Math.abs(r[n][e]);if(0!==s){let a=0;for(let n=e;n<t;n++)r[n][e]/=s,a+=r[n][e]*r[n][e];let i=r[e][e];l=-Math.sign(i)*Math.sqrt(a);let o=i*l-a;r[e][e]=i-l;for(let l=e+1;l<n;l++){a=0;for(let n=e;n<t;n++)a+=r[n][e]*r[n][l];i=a/o;for(let n=e;n<t;n++)r[n][l]+=i*r[n][e]}for(let n=e;n<t;n++)r[n][e]*=s}if(a[e]=s*l,l=0,s=0,e<n-1){for(let t=e+1;t<n;t++)s+=Math.abs(r[e][t]);if(0!==s){let a=0;for(let t=e+1;t<n;t++)r[e][t]/=s,a+=r[e][t]*r[e][t];let i=r[e][e+1];l=-Math.sign(i)*Math.sqrt(a);let c=i*l-a;r[e][e+1]=i-l;for(let t=e+1;t<n;t++)o[t]=r[e][t]/c;for(let i=e+1;i<t;i++){a=0;for(let t=e+1;t<n;t++)a+=r[i][t]*r[e][t];for(let t=e+1;t<n;t++)r[i][t]+=a*o[t]}for(let t=e+1;t<n;t++)r[e][t]*=s}}c=Math.max(c,Math.abs(a[e])+Math.abs(l)),o[e]=l}for(let e=n-1;e>=0;e--){if(e<n-1&&0!==o[e])for(let t=e+1;t<n;t++){let a=0;for(let o=e+1;o<n;o++)a+=r[e][o]*i[o][t];a=a/r[e][e+1]/o[e];for(let o=e+1;o<n;o++)i[o][t]+=a*r[e][o]}for(let r=e+1;r<n;r++)i[e][r]=0,i[r][e]=0;i[e][e]=1}const u=Array.from({length:t},(()=>new Array(n).fill(0)));for(let e=n-1;e>=0;e--){let i=e+1;l=a[e];for(let t=i;t<n;t++)r[e][t]=0;if(0!==l){l=1/l;for(let a=i;a<n;a++){let n=0;for(let o=i;o<t;o++)n+=r[o][e]*r[o][a];let o=n/r[e][e]*l;for(let n=e;n<t;n++)r[n][a]+=o*r[n][e]}for(let n=e;n<t;n++)r[n][e]*=l}else for(let n=e;n<t;n++)r[n][e]=0;r[e][e]+=1}for(let e=0;e<t;e++)for(let t=0;t<n;t++)u[e][t]=r[e][t];const f=30*n;for(let e=n-1;e>=0;e--)for(let r=0;r<f;r++){let s=!0,d=e;for(;d>=0;d--){if(0===d||Math.abs(o[d-1])+c===c){s=!1;break}if(Math.abs(a[d-1])+c===c)break}let g=0,h=1;if(s&&d>0)for(let r=d;r<=e;r++){let e=h*o[r];if(o[r]=g*o[r],Math.abs(e)+c===c)break;l=a[r];let n=Math.hypot(e,l);a[r]=n,n=1/n,g=l*n,h=-e*n;for(let e=0;e<t;e++){let t=u[e][d-1],n=u[e][r];u[e][d-1]=t*g+n*h,u[e][r]=n*g-t*h}}let p=a[e];if(d===e){if(p<0){a[e]=-p;for(let r=0;r<n;r++)i[r][e]=-i[r][e]}break}if(r===f-1)throw new Error("svdDecompose error: No convergence after maximum iterations.");let m=a[d],$=a[e-1];l=o[e-1];let y=o[e],v=(($-p)*($+p)+(l-y)*(l+y))/(2*y*$);l=Math.hypot(v,1),v=((m-p)*(m+p)+y*($/(v+(v>=0?1:-1)*l)-y))/m,g=1,h=1;for(let r=d;r<e;r++){let e=r+1;l=o[e],$=a[e],y=h*l,l*=g,p=Math.hypot(v,y),o[r]=p,g=v/p,h=y/p,v=m*g+l*h,l=l*g-m*h,y=$*h,$*=g;for(let t=0;t<n;t++)m=i[t][r],p=i[t][e],i[t][r]=m*g+p*h,i[t][e]=p*g-m*h;p=Math.hypot(v,y),a[r]=p,0!==p&&(p=1/p,g=v*p,h=y*p),v=g*l+h*$,m=g*$-h*l;for(let n=0;n<t;n++)$=u[n][r],p=u[n][e],u[n][r]=$*g+p*h,u[n][e]=p*g-$*h}o[d]=0,o[e]=v,a[e]=m}return{u:u,s:a,v:i}}function t(e,r){const t=e.length;if(0===t)return[];const n=e[0].length,a=r.length;if(0===a)return e.map((e=>[]));const i=r[0].length;if(n!==a)throw new Error(`Matrix dimension mismatch: A(${t}x${n}), B(${a}x${i})`);const o=new Array(t);for(let a=0;a<t;a++){o[a]=new Array(i).fill(0);for(let t=0;t<i;t++)for(let i=0;i<n;i++){if(void 0===e[a]?.[i]||void 0===r[i]?.[t])throw new Error(`Undefined element accessed: A[${a}][${i}] or B[${i}][${t}]`);o[a][t]+=e[a][i]*r[i][t]}}return o}function n(e){const r=e.length;if(0===r)return[];const t=e[0].length;if(0===t)return e.map((()=>[]));const n=new Array(t);for(let a=0;a<t;a++){n[a]=new Array(r);for(let t=0;t<r;t++){if(void 0===e[t]?.[a])throw new Error(`Undefined element accessed during transpose at [${t}][${a}]`);n[a][t]=e[t][a]}}return n}e.LM_SVD_HELPERS={solveLinearSystem:function(e,r){const t=r.length;if(!e||e.length!==t||e.some((e=>!e||e.length!==t)))throw new Error(`Invalid matrix or vector size for solveLinearSystem. Matrix: ${e?.length}x${e?.[0]?.length}, Vector: ${t}`);const n=e.map(((e,t)=>[...e,r[t]]));for(let e=0;e<t;e++){let r=e;for(let a=e+1;a<t;a++)Math.abs(n[a][e])>Math.abs(n[r][e])&&(r=a);if([n[e],n[r]]=[n[r],n[e]],Math.abs(n[e][e])<1e-12){let r=!1;for(let a=e+1;a<t;a++)if(Math.abs(n[a][e])>=1e-12){[n[e],n[a]]=[n[a],n[e]],r=!0;break}if(!r)throw new Error(`Matrix is singular or near-singular during Gaussian elimination at step ${e}.`)}for(let r=e+1;r<t;r++){const a=n[r][e]/n[e][e];if(!isFinite(a))throw new Error(`Non-finite factor encountered during elimination at [${r},${e}]. Pivot: ${n[e][e]}`);n[r][e]=0;for(let i=e+1;i<=t;i++)n[r][i]-=a*n[e][i]}}const a=new Array(t).fill(0);for(let e=t-1;e>=0;e--){if(Math.abs(n[e][e])<1e-12)throw new Error(`Zero pivot encountered during back substitution at step ${e}.`);let r=0;for(let i=e+1;i<t;i++)r+=n[e][i]*a[i];if(a[e]=(n[e][t]-r)/n[e][e],!isFinite(a[e]))throw new Error(`Non-finite solution component encountered at index ${e}. Pivot: ${n[e][e]}`)}return a},svdDecompose:r,multiplyMatrices:t,transposeMatrix:n,invertMatrixUsingSVD:function(e){const a=e.length;if(0===a||e.some((e=>!e||e.length!==a)))throw new Error("Matrix must be square for SVD inversion.");const{u:i,s:o,v:l}=r(e);if(!i||0===i.length||!o||0===o.length||!l||0===l.length)throw new Error("SVD decomposition failed or returned empty matrices.");const s=i[0]?.length,c=o.length,u=l.length,f=l[0]?.length;s===a&&c===a&&u===a&&f===a||console.warn(`SVD returned unexpected dimensions: U(${i.length}x${s}), S(${c}), V(${u}x${f}) for input NxN (${a}x${a})`);const d=new Array(a).fill(0).map((()=>new Array(a).fill(0))),g=Math.min(a,o.length);for(let e=0;e<g;e++)Math.abs(o[e])>1e-10?d[e][e]=1/o[e]:d[e][e]=0;const h=l,p=n(i);if(p.length!==a)throw new Error(`Dimension mismatch for U transpose: Expected ${a} rows, got ${p.length}`);const m=t(h,d),$=t(m,p);return $.length===a&&$[0]?.length===a||console.warn(`SVD inverse resulted in non-square matrix (${$.length}x${$[0]?.length}) for square input (${a}x${a}).`),$}}}("undefined"!=typeof window?window:global),function(e){"use strict";if(!e.LM_SVD_HELPERS)throw new Error("Error: svd.js must be loaded before globalfit.js");const{solveLinearSystem:r,invertMatrixUsingSVD:t}=e.LM_SVD_HELPERS,n={none:0,error:1,warn:2,info:3,debug:4};const a=1e-14;function i(e){const r=[.9999999999998099,676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,1.5056327351493116e-7];if(e<=0)return 1/0;if(e<.5)return Math.log(Math.PI/Math.sin(Math.PI*e))-i(1-e);const t=e-1;let n=r[0];const a=t+7+.5;for(let e=1;e<r.length;e++)n+=r[e]/(t+e);return(t+.5)*Math.log(a)-a+Math.log(Math.sqrt(2*Math.PI)*n)}function o(e,r,t){let n=1,i=n,o=0,l=0,s=0;do{s++;const c=s-1,u=2*c;let f=(r+u)*(r+u+1),d=0===f?0:-(r+c)*(r+t+c)*e/f,g=0;if(c>0){let n=(r+u-1)*(r+u);g=0===n?0:c*(t-c)*e/n}if(o=1+d*o,Math.abs(o)<a&&(o=a),i=1+d/i,Math.abs(i)<a&&(i=a),o=1/o,l=i*o,n*=l,c>0&&(o=1+g*o,Math.abs(o)<a&&(o=a),i=1+g/i,Math.abs(i)<a&&(i=a),o=1/o,l=i*o,n*=l),Math.abs(l-1)<a)break}while(s<150);return s>=150&&console.warn("_jstat_ibeta_cont_frac: Failed to converge."),n}function l(e,r,t){if(e<0||e>1||r<=0||t<=0)return NaN;if(0===e)return 0;if(1===e)return 1;const n=i(r)+i(t)-i(r+t),a=r*Math.log(e)+t*Math.log(1-e),l=Math.exp(a-n);return e<(r+1)/(r+t+2)?l*o(e,r,t)/r:1-l*o(1-e,t,r)/t}function s(e,r){if(e<0||e>1||r<=0||!isFinite(r))return NaN;if(0===e)return-1/0;if(1===e)return 1/0;if(.5===e)return 0;let t=function(e,r,t){if(e<0||e>1||r<=0||t<=0)return NaN;if(0===e)return 0;if(1===e)return 1;const n=1e-12;let a=0,o=1,s=.5,c=.5;s=e<.5?Math.pow(e*r*Math.exp(i(r)+i(t)-i(r+t)),1/r):1-Math.pow((1-e)*t*Math.exp(i(r)+i(t)-i(r+t)),1/t),s<=0&&(s=n),s>=1&&(s=1-n);const u=i(r)+i(t)-i(r+t);for(let i=0;i<100;i++){const i=l(s,r,t)-e;let f=(r-1)*Math.log(s)+(t-1)*Math.log(1-s)-u,d=Math.exp(f);c=0!==d&&isFinite(d)?i/d:i>0?-1e-11:1e-11;let g=s-c;if(i>0?o=s:a=s,(g<=a||g>=o)&&(g=(a+o)/2,c=s-g),s=g,Math.abs(c)<n||Math.abs(i)<n)return s}return console.warn(`_jstat_ibeta_inv: Failed to converge. p=${e}, a=${r}, b=${t}. Est: ${s}`),s}(e<.5?2*e:2*(1-e),.5*r,.5);if(isNaN(t)||0===t)return e<.5?-1/0:1/0;if(1===t)return 0;let n=r*(1-t)/t;if(n<0)return console.warn(`_jstat_studentt_inv: Negative t_squared (${n}).`),NaN;let a=Math.sqrt(n);return e<.5?-a:a}function c(e,r){const t=e.length;if(0===t)return[];const n=e[0]?.length??0;if(0===n&&0===r.length)return[];if(0===n&&r.length>0)throw new Error("Jacobian has zero columns but residuals exist.");if(t!==r.length)throw new Error(`Jacobian rows (${t}) must match residuals length (${r.length}).`);const a=new Array(n).fill(0);for(let i=0;i<n;i++)for(let n=0;n<t;n++){if(void 0===e[n]?.[i]||!isFinite(e[n][i])||void 0===r[n]||!isFinite(r[n]))throw new Error(`Invalid value in gradient calculation at point ${n}, param ${i}.`);a[i]+=e[n][i]*r[n]}return a}function u(e){const r=e.length;if(0===r)return[];const t=e[0]?.length??0;if(0===t)return[];const n=new Array(t).fill(0).map((()=>new Array(t).fill(0)));for(let a=0;a<t;a++)for(let i=a;i<t;i++){let t=0;for(let n=0;n<r;n++){if(void 0===e[n]?.[a]||!isFinite(e[n][a])||void 0===e[n]?.[i]||!isFinite(e[n][i]))throw new Error(`Invalid value in Hessian calculation at point ${n}, params ${a}, ${i}.`);t+=e[n][a]*e[n][i]}n[a][i]=t,a!==i&&(n[i][a]=t)}return n}function f(e,r,t,n,a,i,o){const l=t(n);let s=0;return e.x.forEach(((t,n)=>{const i=e.y[n],c=e.ye[n],u=r[n],f=l[n];if(!(t&&i&&c&&u&&f&&t.length===i.length&&t.length===c.length))return o(`Data length/param mismatch dataset ${n}`,"error"),NaN;for(let e=0;e<t.length;e++){0;const r=t[e],l=i[e],d=c[e];if(0===d){o(`Zero error point ${e} ds ${n}. Skipping.`,"warn");continue}if(!isFinite(l)||!isFinite(d)){o(`Non-finite y/ye point ${e} ds ${n}. Skipping.`,"warn");continue}let g=0;try{u.forEach(((e,t)=>{if(!f[t])throw new Error(`Missing params ds ${n}, pIdx ${t}.`);const a=e(f[t],[r]);if(!a||1!==a.length||!isFinite(a[0]))throw new Error(`Model ${n}-${t} invalid result x=${r}: ${JSON.stringify(a)}`);g+=a[0]}))}catch(r){return o(`Error evaluating model ds ${n}, pt ${e}: ${r.message}`,"error"),NaN}if(!isFinite(g)){o(`Non-finite model value pt ${e} ds ${n}. Skipping.`,"warn");continue}const h=(l-g)/d;s+=1===a?Math.abs(h):2===a?Math.log(1+.5(h*h)):h*h}})),isFinite(s)?s:(o("Non-finite chi-squared calculated.","error"),1/0)}function d(e,r,t,n,a,i,o,l){const s=t(n),c=[],u=[],f=a.length;if(e.x.forEach(((a,o)=>{const d=e.y[o],g=e.ye[o],h=r[o],p=s[o];if(!(a&&d&&g&&h&&p&&a.length===d.length&&a.length===g.length))throw new Error(`Data length mismatch ds ${o} Jacobian.`);for(let e=0;e<a.length;e++){0;const r=a[e],s=d[e],m=g[e];if(0===m)throw new Error(`Zero error pt ${e} ds ${o} Jacobian.`);if(!isFinite(s)||!isFinite(m))throw new Error(`Non-finite y/ye pt ${e} ds ${o} Jacobian.`);let $=0;try{h.forEach(((e,t)=>{if(!p[t])throw new Error(`Missing params ds ${o}, pIdx ${t} (Jacobian orig).`);const n=e(p[t],[r]);if(!n||1!==n.length||!isFinite(n[0]))throw new Error(`Model ${o}-${t} invalid result x=${r}: ${JSON.stringify(n)}`);$+=n[0]}))}catch(r){throw l(`Error evaluating model (orig) ds ${o}, pt ${e}: ${r.message}`,"error"),r}if(!isFinite($))throw new Error(`Non-finite orig model value pt ${e} ds ${o}.`);const y=(s-$)/m;c.push(y);const v=new Array(f).fill(0);for(let a=0;a<f;a++){const s=[...n],c=s[a];let u=i*Math.abs(c)+i;0===u&&(u=i),s[a]+=u;const f=t(s);let d=0,g=!1;try{const e=f[o];h.forEach(((t,n)=>{if(g)return;if(!e||!e[n])throw new Error(`Missing params ds ${o}, pIdx ${n} (Jacobian pert).`);const a=t(e[n],[r]);if(!a||1!==a.length||!isFinite(a[0]))return l(`Model ${o}-${n} invalid result during perturbation x=${r}`,"warn"),void(g=!0);d+=a[0]}))}catch(r){l(`Error evaluating model (pert) ds ${o}, pt ${e}, actP ${a}: ${r.message}`,"error"),g=!0}if(g||!isFinite(d))l(`Non-finite/failed pert model value pt ${e}, ds ${o}, actP ${a}. Deriv=0.`,"warn"),v[a]=0;else{const e=(d-$)/u;v[a]=-e/m}isFinite(v[a])||(l(`Non-finite Jacobian element pt ${e}, ds ${o}, actP ${a}. Setting=0.`,"warn"),v[a]=0)}u.push(v)}})),c.length!==u.length)throw new Error(`Internal error: Residuals (${c.length}) != Jacobian rows (${u.length})`);if(u.length>0&&u[0].length!==f)throw new Error(`Internal error: Jacobian cols (${u[0].length}) != active params (${f})`);return{jacobian:u,residuals:c}}function g(e,r,t,n,a,i){let o=e,l=!1,s=!1;if(r){let a=null;n.forEach(((n,i)=>{r[i]&&n.forEach(((n,o)=>{if(r[i][o])for(let c=0;c<n;c++){const n=r[i]?.[o]?.[c];if(n){a||(a=JSON.parse(JSON.stringify(e)));let r=a[i][o][c];const u=r;if(void 0!==n.min&&r<n.min&&(r=n.min),void 0!==n.max&&r>n.max&&(r=n.max),r!==u){a[i][o][c]=r,s=!0;t.some((e=>e.originalCoord[0][0]===i&&e.originalCoord[0][1]===o&&e.originalCoord[1]===c))&&(l=!0)}}}}))})),a&&(o=a)}if("function"==typeof a)try{const r=s?o:e,t=s?null:JSON.stringify(r);if(o=a(r),!Array.isArray(o)||o.length!==n.length)throw new Error("Constraint function did not return a valid parameter structure.");const c=JSON.stringify(o);s||c===t?s&&c!==JSON.stringify(r)&&(l=!0,i("Custom constraint function modified parameters after box constraints.","debug")):(l=!0,i("Custom constraint function modified parameters.","debug"))}catch(r){i(`Error executing custom constraint function: ${r.message}`,"error"),o=s?JSON.parse(JSON.stringify(e)):e}return{constrainedParams:o,changedActive:l}}function h(e,r,t,n){if(!(e&&e.x&&e.y&&e.ye&&r&&t))return n("Missing data/models/params for final residual calculation.","error"),null;const a=[];let i=!1;return e.x.forEach(((o,l)=>{const s=e.y[l],c=e.ye[l],u=r[l],f=t[l],d=[];if(!(s&&c&&u&&f&&o.length===s.length&&o.length===c.length))return n(`Inconsistent data/model/params for dataset ${l} in final residual calculation. Skipping.`,"warn"),void a.push([]);for(let e=0;e<o.length;e++){const r=o[e],t=s[e],a=c[e];if(0===a||!isFinite(t)||!isFinite(a)){n(`Invalid data/error at point ${e} in dataset ${l} for final residuals. Storing NaN.`,"warn"),d.push(NaN);continue}let g=0,h=!1;try{u.forEach(((e,t)=>{if(!f[t])throw new Error(`Missing params for model ${t}.`);const n=e(f[t],[r]);if(!n||1!==n.length||!isFinite(n[0]))throw new Error(`Model ${l}-${t} returned invalid result.`);g+=n[0]}))}catch(r){n(`Error evaluating model for final residual at ds ${l}, pt ${e}: ${r.message}`,"error"),h=!0,i=!0}h||!isFinite(g)?d.push(NaN):d.push((t-g)/a)}a.push(d)})),i?null:a}function p(e,r,t,n){let a=null,i=null;if(r&&Array.isArray(r)&&2===r.length){const e=Number(r[0]),o=Number(r[1]);isFinite(e)&&isFinite(o)&&e<=o?(a=e,i=o,n(`Using provided x-range [${a}, ${i}] for series ${t} curve.`,"debug")):n(`Provided model_x_range for series ${t} is invalid [${r[0]}, ${r[1]}]. Falling back to data range.`,"warn")}else null!=r&&n(`Provided model_x_range for series ${t} is not an array of two numbers. Falling back to data range.`,"warn");if(null===a||null===i)if(n(`Determining x-range from data for series ${t} curve.`,"debug"),e&&e.length>0)try{const r=e.filter((e=>isFinite(e)));if(!(r.length>0))return n(`No finite x-data found for series ${t}. Cannot determine data range.`,"error"),null;a=Math.min(...r),i=Math.max(...r)}catch(e){return n(`Error determining data range for series ${t}: ${e.message}`,"error"),null}else a=0,i=0;return null!==a&&null!==i&&isFinite(a)&&isFinite(i)?{min:a,max:i}:(n(`Could not determine valid x-range for series ${t}.`,"error"),null)}function m(e,r,t,n,a,i,o,l,c,u,f,d,g,h){if(!(e&&e.x&&r&&t&&Array.isArray(t)))return a("Missing or invalid primary arguments for fitted curve calculation.","error"),{curves:null,negativeVarianceEncountered:!1};if(n<=1)return a(`Invalid numPoints (${n}) for fitted curve calculation.`,"error"),{curves:null,negativeVarianceEncountered:!1};null!==i&&("number"!=typeof i||i<=0||i>=1)&&(a(`Invalid confidenceLevel (${i}) passed internally.`,"warn"),i=null);let m=!1,$=!1;const y=[],v=o?.length??0,w=null!==i&&o&&v>0&&l&&Array.isArray(l)&&l.length===v&&l[0]?.length===v&&d>0&&isFinite(d)&&c&&Array.isArray(c)&&c.length===v&&"function"==typeof u&&isFinite(f)&&f>0;null===i||w||a("Standard CI calculation prerequisites not met. Skipping standard CI calculation.","warn");try{e.x.forEach(((e,c)=>{if(!(e&&Array.isArray(e)&&r[c]&&t[c]))return a(`Skipping dataset ${c}: Missing data, model, or params.`,"warn"),void y.push(null);const g=r[c],N=t[c],x={x:[],y:[],ci_lower:[],ci_upper:[]};let b=w,M=NaN;if(b){M=function(e,r,t){if(r<=0)return t(`Cannot calculate t-value: Degrees of freedom (${r}) must be positive.`,"warn"),NaN;if(e<=0||e>=1)return t(`Cannot calculate t-value: Cumulative probability (${e}) must be between 0 and 1.`,"warn"),NaN;try{const n=s(e,r);return isFinite(n)?n:(t(`Calculated t-value is not finite (${n}) for p=${e}, dof=${r}.`,"warn"),NaN)}catch(e){return t(`Error calculating t-value: ${e.message}`,"error"),NaN}}(1-(1-i)/2,d,a),isNaN(M)&&(a(`Failed to calculate critical t-value for dataset ${c}. Skipping CI calculation.`),b=!1)}const E=p(e,h?.[c]??null,c,a);if(null===E)return a(`Invalid X range for dataset ${c}. Skipping curve calculation.`,"warn"),void y.push(null);const{min:A,max:S}=E,F=S===A||n<=1?0:(S-A)/(n-1);for(let e=0;e<n;e++){const r=0===F?A:A+e*F;let t=0,n=!1,i=NaN,s=NaN;try{if(g.forEach(((e,n)=>{if(!N[n])throw new Error(`Missing params for model ${n}.`);const a=e(N[n],[r]);if(!a||1!==a.length||!isFinite(a[0]))throw new Error(`Model ${c}-${n} returned invalid result.`);t+=a[0]})),!isFinite(t))throw new Error("Calculated y value is not finite.")}catch(e){a(`Error evaluating model for fitted curve at ds ${c}, x=${r.toFixed(3)}: ${e.message}`,"error"),n=!0,m=!0,t=NaN}if(b&&isFinite(t))try{const e=new Array(v).fill(0);for(let n=0;n<v;n++){const i=[...o],l=i[n];let s=f*Math.abs(l)+f;0===s&&(s=f),i[n]+=s;const d=u(i)[c];let h=0,p=!1;try{if(g.forEach(((e,t)=>{if(p)return;if(!d||!d[t])throw new Error(`Missing perturbed params ds ${c}, pIdx ${t}.`);const n=e(d[t],[r]);n&&1===n.length&&isFinite(n[0])?h+=n[0]:p=!0})),p||!isFinite(h))throw new Error("Perturbed model evaluation failed or yielded non-finite result.")}catch(e){a(`Error evaluating perturbed model (ds ${c}, x=${r.toFixed(3)}, actP ${n}): ${e.message}. Derivative set to 0.`,"warn"),p=!0}e[n]=p?0:(h-t)/s,isFinite(e[n])||(a(`Non-finite model Jacobian element (ds ${c}, x=${r.toFixed(3)}, actP ${n}). Setting to 0.`,"warn"),e[n]=0)}let n=0;for(let r=0;r<v;r++)for(let t=0;t<v;t++){if(!l[r]||!isFinite(l[r][t]))throw new Error(`Invalid covariance matrix element Cov[${r}][${t}]: ${l[r]?.[t]}`);if(!isFinite(e[r])||!isFinite(e[t]))throw new Error("Non-finite Jacobian element encountered during variance calculation.");n+=e[r]*l[r][t]*e[t]}if(!isFinite(n))throw new Error(`Calculated variance is not finite (${n}).`);n<0&&(a(`Warning: Calculated variance for CI at x=${r.toFixed(3)} is negative (${n.toExponential(3)}). Using absolute value for SE.`),$=!0,n=Math.abs(n));const d=Math.sqrt(n);if(!isFinite(d))throw new Error("Calculated standard error is not finite.");const h=M*d;i=t-h,s=t+h,isFinite(i)&&isFinite(s)||(a(`Non-finite CI bound calculated at x=${r.toFixed(3)}. Setting to NaN.`),i=NaN,s=NaN)}catch(e){a(`Error calculating standard confidence interval at ds ${c}, x=${r.toFixed(3)}: ${e.message}`,"error"),i=NaN,s=NaN}x.x.push(r),x.y.push(t),b&&(x.ci_lower.push(i),x.ci_upper.push(s))}b&&x.ci_lower.length>0?y.push(x):y.push({x:x.x,y:x.y})}))}catch(e){return a(`Error processing datasets for curve calculation: ${e.message}`,"error"),{curves:null,negativeVarianceEncountered:$}}const N=y.filter((e=>null!==e));return{curves:N.length>0?N:null,negativeVarianceEncountered:$}}async function $(e,a,i,o={}){const l=o.onLog&&"function"==typeof o.onLog?o.onLog:()=>{},s=o.logLevel??"info",y=n[s.toLowerCase()]??n.info,v=(e,r)=>{y>=(n[r]??n.info)&&l(e,r)},w=o.maxIterations??100,N=o.errorTolerance??1e-6,x=o.gradientTolerance??1e-6,b=o.linkMap??null,M=o.fixMap??null,E=o.constraints??null,A=o.constraintFunction??null,S=o.robustCostFunction??null;let F=o.lambdaInitial??.001;const C=o.lambdaIncreaseFactor??10,I=o.lambdaDecreaseFactor??10,P=o.epsilon??1e-8,_=o.calculateFittedModel??!1,k="object"==typeof _&&_.numPoints>1?_.numPoints:300,q=!0===_||"object"==typeof _,J=o.covarianceLambda??1e-9,L=o.bootstrapFallback??!0,O=o.numBootstrapSamples??200;let D=null;null!==o.confidenceInterval&&void 0!==o.confidenceInterval&&("number"==typeof o.confidenceInterval&&o.confidenceInterval>0&&o.confidenceInterval<1?D=o.confidenceInterval:v(`Invalid confidenceInterval option (${o.confidenceInterval}). Must be a number between 0 and 1 (exclusive). Confidence intervals will not be calculated.`,"warn"));const B=o.model_x_range??null;v("Starting lmFitGlobal (v1.2.6 - Added CI Bands)...");let R=0;e&&e.x&&e.x.forEach((e=>{Array.isArray(e)?R+=e.length:v("Non-array in data.x.","warn")})),v(`Total data points (N): ${R}`);const j={p_active:[],p_reconstructed:i,finalParamErrors:null,chiSquared:NaN,covarianceMatrix:null,parameterErrors:null,iterations:0,converged:!1,activeParamLabels:[],totalPoints:R,degreesOfFreedom:NaN,reducedChiSquared:NaN,aic:NaN,aicc:NaN,bic:NaN,residualsPerSeries:null,fittedModelCurves:null};if(0===R){const e="No data points.";return v(e,"error"),{...j,error:e}}let V;try{V=function(e,r,t,n){n("--- Running setupParameterMapping (New linkMap structure v1.4.3 logic) ---","debug"),n("Received linkMapInput (structure like fixMap): "+(r?"Provided":"Null"),"debug"),n(`Received fixMapInput: ${JSON.stringify(t)}`,"debug");const a=[],i=[],o=[],l=t?JSON.parse(JSON.stringify(t)):[],s=r?JSON.parse(JSON.stringify(r)):null;e.forEach(((e,r)=>{a.push([]),l[r]||(l[r]=[]),e.forEach(((e,t)=>{a[r].push(e.length),l[r][t]||(l[r][t]=new Array(e.length).fill(!1)),e.forEach(((e,n)=>{i.push(e),o.push([[r,t],n]),l[r][t].length<=n&&(l[r][t][n]=!1)}))}))}));const c=i.length,u=new Array(c).fill(-1),f=new Array(c).fill(!1),d=[],g=[],h=[];o.forEach(((e,r)=>{const[[t,n],a]=e;!0===l[t]?.[n]?.[a]&&(f[r]=!0)})),n(`Initial isFixed array (after fixMap): ${JSON.stringify(f)}`,"debug");const p={};s?(s.forEach(((r,t)=>{!r||t>=e.length||r.forEach(((r,a)=>{!r||a>=e[t].length||r.forEach(((r,i)=>{if(!(i>=e[t][a].length)&&null!=r&&""!==r){const e=[t,a,i],l=o.findIndex((r=>r[0][0]===e[0]&&r[0][1]===e[1]&&r[1]===e[2]));-1!==l?(p[r]||(p[r]=[]),p[r].push(l)):n(`Could not find flat index for link coordinate [${e.join(", ")}]`,"warn")}}))}))})),n(`Collected Link Groups by ID: ${JSON.stringify(p)}`,"debug"),Object.entries(p).forEach((([e,r])=>{if(r.length<2)return void n(`Link Group ${e} has only one member (${r[0]}). Ignoring link.`,"debug");n(`Processing Link Group ${e}: Flat indices ${JSON.stringify(r)}`,"debug");let t=-1,a=null,l=!0;for(const i of r)i<0||i>=c?n(`  Invalid flat index ${i} found in link group ${e}. Skipping.`,"warn"):f[i]||(l=!1,-1===t&&(t=i,a=o[i]));if(l){if(t=r[0],t<0||t>=c)return void n(`  Invalid nominal master index ${t} for fixed group ${e}. Skipping group.`,"warn");n(`  Link Group ${e} consists entirely of initially fixed parameters. Nominal master: flat index ${t}`,"debug"),f[t]||(n(`  Marking nominal master ${JSON.stringify(o[t])} (flat ${t}) as fixed because entire group is fixed.`,"debug"),f[t]=!0),r.forEach((e=>{e<0||e>=c||(e!==t?(u[e]=t,i[e]=i[t],n(`    Linked fixed slave ${JSON.stringify(o[e])} (flat ${e}) to fixed master ${t}. State: isFixed=${f[e]}, masterMap=${u[e]}`,"debug")):n(`    Nominal Master ${JSON.stringify(o[e])} (flat ${e}). State: isFixed=${f[e]}, masterMap=${u[e]}`,"debug"))}))}else-1!==t?(n(`  Link Group ${e} master: ${JSON.stringify(a)} (flat index ${t})`,"debug"),n(`    Master ${JSON.stringify(o[t])} (flat ${t}). State: isFixed=${f[t]}, masterMap=${u[t]}`,"debug"),r.forEach((e=>{if(!(e<0||e>=c)&&e!==t){const r=f[e];f[e]&&(n(`    Linking overrides fixed status for ${JSON.stringify(o[e])} (flat ${e}).`,"warn"),f[e]=!1),u[e]=t,i[e]=i[t],n(`    Linked slave ${JSON.stringify(o[e])} (flat ${e}) to master ${t}. InitialFixed=${r}. Final State: isFixed=${f[e]}, masterMap=${u[e]}`,"debug")}}))):n(`  Internal Logic Error: Could not determine master type for group ${e}.`,"error")}))):n("No linkMap provided or linkMap is null.","debug"),n(`Final isFixed array (after linking): ${JSON.stringify(f)}`,"debug"),n(`Final masterMap array: ${JSON.stringify(u)}`,"debug");let m=0;for(let e=0;e<c;e++)if(!f[e]&&-1===u[e]){d.push({originalCoord:o[e],flatIndex:e,activeIndex:m}),g.push(i[e]);const[[r,t],n]=o[e];h.push(`ds${r}_p${t}_v${n}`),m++}const $=g.length;return n(`Identified ${$} active parameters: ${JSON.stringify(h)}`,"debug"),n(`Active Initial Params: ${JSON.stringify(g)}`,"debug"),{activeInitialParams:g,reconstructParams:e=>{if(e.length!==$)throw new Error(`reconstructParams expects ${$} params, received ${e.length}`);const r=[...i];d.forEach(((t,n)=>{if(n>=e.length)throw new Error("Mismatch activeParamInfo/activeParams.");r[t.flatIndex]=e[n]}));for(let e=0;e<c;e++)if(-1!==u[e]){if(u[e]<0||u[e]>=r.length)throw new Error(`Master index ${u[e]} out of bounds.`);r[e]=r[u[e]]}const t=[];let o=0;return a.forEach(((e,n)=>{t[n]=[],e.forEach(((e,a)=>{t[n][a]=[];for(let i=0;i<e;i++){if(o>=r.length)throw new Error(`Flat index ${o} out of bounds.`);t[n][a][i]=r[o],o++}}))})),o!==c&&n(`Param reconstruction mismatch: ${o} vs ${c}`,"warn"),t},activeParamInfo:d,totalActiveParams:$,paramStructure:a,activeParamLabels:h,isFixed:f,masterMap:u,paramCoordinates:o,nTotalParams:c}}(i,b,M,v)}catch(e){const r=`Parameter setup failed: ${e.message}`;return v(r,"error"),{...j,error:r}}const{activeInitialParams:G,reconstructParams:U,activeParamInfo:W,totalActiveParams:T,paramStructure:H,activeParamLabels:z}=V,K=T,{isFixed:X,masterMap:Z,paramCoordinates:Q,nTotalParams:Y}=function(e,r,t){const n=[],a=[];let i=0;const o=t?JSON.parse(JSON.stringify(t)):[],l=r?JSON.parse(JSON.stringify(r)):null;e.forEach(((e,r)=>{n.push([]),o[r]||(o[r]=[]),e.forEach(((e,t)=>{n[r].push(e.length),o[r][t]||(o[r][t]=new Array(e.length).fill(!1)),e.forEach(((e,n)=>{a.push([[r,t],n]),o[r][t].length<=n&&(o[r][t][n]=!1),i++}))}))}));const s=i,c=new Array(s).fill(-1),u=new Array(s).fill(!1);a.forEach(((e,r)=>{const[[t,n],a]=e;!0===o[t]?.[n]?.[a]&&(u[r]=!0)}));const f={};return l&&(l.forEach(((r,t)=>{!r||t>=e.length||r.forEach(((r,n)=>{!r||n>=e[t].length||r.forEach(((r,i)=>{if(!(i>=e[t][n].length)&&null!=r&&""!==r){const e=[t,n,i],o=a.findIndex((r=>r[0][0]===e[0]&&r[0][1]===e[1]&&r[1]===e[2]));-1!==o&&(f[r]||(f[r]=[]),f[r].push(o))}}))}))})),Object.values(f).forEach((e=>{if(e.length<2)return;let r=-1,t=!0;for(const n of e)n<0||n>=s||u[n]||(t=!1,-1===r&&(r=n));if(t){if(r=e[0],r<0||r>=s)return;u[r]||(u[r]=!0),e.forEach((e=>{e<0||e>=s||e!==r&&(c[e]=r)}))}else-1!==r&&e.forEach((e=>{e<0||e>=s||e!==r&&(u[e]&&(u[e]=!1),c[e]=r)}))}))),{isFixed:u,masterMap:c,paramCoordinates:a,nTotalParams:s,paramStructure:n}}(i,b,M);if(0===K){v("No active parameters to fit. Calculating initial stats.","warn");let r=NaN,t=R,n=NaN,i=NaN,o=NaN,l=NaN,s=null,c=null,u=null;const d=U([]);try{r=f(e,a,U,[],S,0,v),s=h(e,a,d,v),q&&(c=m(e,a,d,k,v,null,[],null,[],U,P,t,0,B)),u=[];let g=0;H.forEach(((e,r)=>{u[r]=[],e.forEach(((e,t)=>{u[r][t]=[];for(let n=0;n<e;n++)u[r][t][n]=0,g++}))})),isFinite(r)&&t>0?(n=r/t,i=r,l=r,o=R>1?i:1/0):isFinite(r)&&(n=1/0,i=r,l=r,o=1/0,v("Degrees of freedom is zero or negative. Reduced ChiSq and AICc are Infinity.","warn"))}catch(e){v(`Error calculating initial ChiSq/Residuals: ${e.message}`,"error")}return{p_active:[],p_reconstructed:d,finalParamErrors:u,chiSquared:r,covarianceMatrix:[],parameterErrors:[],iterations:0,converged:!0,activeParamLabels:[],totalPoints:R,degreesOfFreedom:t,reducedChiSquared:n,aic:i,aicc:o,bic:l,error:null,residualsPerSeries:s,fittedModelCurves:c}}let ee=[...G],re=NaN;try{re=f(e,a,U,ee,S,0,v)}catch(e){const r=`Initial Chi-Squared calculation failed: ${e.message}`;return v("Non-finite initial Chi-Squared.","error"),{...j,p_reconstructed:U(ee),chiSquared:re,error:r}}let te,ne=!1,ae=null,ie=[],oe=0,le=null;if(v(`Total active parameters (K): ${K}`,"info"),v(`Active Parameter Labels: ${z.join(", ")}`,"info"),v(`Initial Active Parameters: ${ee.map((e=>e.toExponential(3))).join(", ")}`,"info"),v(`Initial Chi-Squared: ${re}`,"info"),!isFinite(re)){const e="Initial Chi-Squared is not finite.";return v("Non-finite initial Chi-Squared.","error"),{...j,p_reconstructed:U(ee),chiSquared:re,error:e}}for(te=0;te<w;te++){let t,n,i,l;oe=te+1,v(`--- Iteration ${oe} (Lambda: ${F.toExponential(3)}) ---`,"info"),v(`Iter ${oe} - Current Active Params: ${ee.map((e=>e.toExponential(5))).join(", ")}`,"debug");try{({jacobian:t,residuals:n}=d(e,a,U,ee,W,P,0,v))}catch(e){const r=`Jacobian failed: ${e.message}`;return v(`Error Jacobian/Resid iter ${oe}: ${r}`,"error"),{...j,p_reconstructed:U(ee),chiSquared:re,iterations:oe,error:r}}try{i=c(t,n),l=u(t)}catch(e){const r=`Grad/Hess failed: ${e.message}`;return v(`Error Grad/Hess iter ${oe}: ${r}`,"error"),{...j,p_reconstructed:U(ee),chiSquared:re,iterations:oe,error:r}}if(i.some((e=>!isFinite(e)))||l.some((e=>e.some((e=>!isFinite(e)))))){const e="Non-finite grad/hess.";return v(`Non-finite grad/hess iter ${oe}.`,"error"),{...j,p_reconstructed:U(ee),chiSquared:re,iterations:oe,error:e}}const s=Math.max(...i.map(Math.abs));if(s<x){v(`Converged (grad tol ${x}). Max Grad: ${s.toExponential(3)}`,"info"),ne=!0;break}let h;v(`Gradient: ${i.map((e=>e.toExponential(3))).join(", ")}`,"info");let p=!1,m=0;const $=5;let y=F;for(;!p&&m<$;){const e=l.map(((e,r)=>e.map(((e,t)=>r===t?e+y:e))));try{const t=i.map((e=>-e));if(h=r(e,t),h.some((e=>!isFinite(e))))throw new Error("NaN/Inf in updates.");p=!0}catch(e){if(m++,v(`Solve failed (Att ${m}/${$}, Iter ${oe}): ${e.message}. Inc lambda.`,"warn"),y=Math.min(y*C*(m>1?C:1),1e10),v(`Attempting solve with Lambda: ${y.toExponential(3)}`,"info"),m>=$){const e="Failed solve.";return v(`Failed solve after ${$} attempts.`,"error"),{...j,p_reconstructed:U(ee),chiSquared:re,iterations:oe,error:e}}}}if(!p)continue;F=y,v(`Parameter Updates: ${h.map((e=>e.toExponential(3))).join(", ")}`,"info");const w=ee.map(((e,r)=>e+h[r]));let b=U(w);const{constrainedParams:M,changedActive:_}=g(b,E,W,H,A,v);b=M;const k=_?W.map((e=>b[e.originalCoord[0][0]][e.originalCoord[0][1]][e.originalCoord[1]])):w;let q=NaN;try{q=f(e,a,U,k,S,0,v)}catch(e){v(`Error ChiSq proposed step iter ${oe}: ${e.message}`,"error"),q=1/0}if(v(`New Chi-Squared: ${q}`,"info"),isFinite(q)&&q<re){const e=re-q;ee=k,re=q,F=Math.max(F/I,1e-12),v(`Accepted. ChiSq decreased by ${e.toExponential(3)}. Lambda decreased to: ${F.toExponential(3)}`,"info");try{o.onProgress?.({iteration:oe,chiSquared:re,lambda:F,activeParameters:[...ee]})}catch(e){v(`Error in onProgress callback: ${e.message}`,"warn")}if(e<N){v(`Converged (chiSq tol ${N}).`,"info"),ne=!0;break}}else F=Math.min(F*C,1e10),v(`Rejected (ChiSq ${isNaN(q)?"NaN":"increased/stagnant"}). Lambda increased to: ${F.toExponential(3)}`,"info"),F>=1e10&&v("Lambda reached maximum limit.","warn")}ne||te!==w||v(`lmFitGlobal did not converge within ${w} iterations.`,"warn"),v("Recalculating final Jacobian/Hessian for covariance...","info");try{const{jacobian:r}=d(e,a,U,ee,W,P,0,v);le=u(r)}catch(e){v(`Failed to recalculate final Hessian: ${e.message}`,"error"),le=null}let se=NaN,ce=NaN,ue=NaN,fe=NaN,de=NaN;if(isFinite(re)&&R>0)if(se=R-K,se>0){ce=re/se,ue=re+2*K;const e=R-K-1;e>0?fe=ue+2*K*(K+1)/e:(fe=1/0,v("AICc denominator (N-K-1) is zero or negative. AICc set to Infinity.","warn")),de=re+K*Math.log(R)}else ce=1/0,ue=re+2*K,de=re+K*Math.log(R),fe=1/0,v(`Degrees of freedom (${se}) is zero or negative. Reduced Chi-Squared is Infinity/undefined. Parameter errors may be unreliable or NaN.`,"warn");else v("Final Chi-Squared is not finite. Cannot calculate statistics reliably.","warn"),se=R-K,ce=NaN,ue=NaN,fe=NaN,de=NaN;if(ie=new Array(K).fill(NaN),ae=null,le&&K>0)try{const e=le.map(((e,r)=>e.map(((e,t)=>r===t?e+J:e))));v(`Applying regularization (lambda=${J}) for covariance matrix inversion.`,"debug"),ae=t(e);const r=ce&&isFinite(ce)&&ce>0?ce:1;1===r&&se>0&&isFinite(re)?v("Reduced Chi-Squared is invalid or not positive. Using scale factor 1.0 for parameter errors, which might underestimate errors if fit is poor.","warn"):1===r&&se<=0&&v("Using scale factor 1.0 for parameter errors due to non-positive degrees of freedom.","info"),ie=ae.map(((e,t)=>{if(t>=e.length)return v(`Error accessing covariance matrix diagonal at index ${t}. Matrix might be malformed.`,"error"),NaN;const n=e[t],a=n*r;let i=NaN;return isFinite(a)&&(a<0?(v(`Negative variance (${a.toExponential(3)}) encountered for active param ${t}. Returning sqrt(abs(variance)). Error estimate might be unreliable.`,"warn"),i=Math.sqrt(Math.abs(a))):i=Math.sqrt(a)),isNaN(i)&&isFinite(a)&&v(`NaN error calc for param ${t}: variance=${n}, scaleFactor=${r}, scaledVariance=${a}`,"debug"),i})),ie.some(isNaN)&&v("NaN encountered in parameter errors (potentially due to non-finite variance/covariance). Check fit quality, model, initial parameters, and data.","warn")}catch(e){v(`Failed to calculate covariance matrix/parameter errors: ${e.message}`,"error"),ie=new Array(K).fill(NaN),ae=new Array(K).fill(0).map((()=>new Array(K).fill(NaN)))}else K>0&&!le?v("Could not calculate covariance matrix (no valid final Hessian?). Parameter errors will be NaN.","warn"):0===K&&v("No active parameters (K=0). Parameter errors are not applicable.","info"),ae=new Array(K).fill(0).map((()=>new Array(K).fill(NaN)));const ge=U(ee);let he=null;try{he=[];let e=0;H.forEach(((r,t)=>{he[t]=[],r.forEach(((r,n)=>{he[t][n]=[];for(let a=0;a<r;a++){let r=NaN;if(X[e])r=0;else if(-1!==Z[e]){const t=Z[e],n=W.find((e=>e.flatIndex===t));n?ie&&n.activeIndex<ie.length?r=ie[n.activeIndex]:(v(`Invalid index ${n.activeIndex} for parameterErrors array (length ${ie?.length}) while processing slave ${e}. Setting error to NaN.`,"warn"),r=NaN):(v(`Could not find active info for master parameter (flat index ${t}) of slave (flat index ${e}). Setting error to 0.`,"warn"),r=0)}else{const t=W.find((r=>r.flatIndex===e));t?ie&&t.activeIndex<ie.length?r=ie[t.activeIndex]:(v(`Invalid index ${t.activeIndex} for parameterErrors array (length ${ie?.length}) while processing active param ${e}. Setting error to NaN.`,"warn"),r=NaN):v(`Could not find active info for supposedly active parameter at flat index ${e}. Setting error to NaN.`,"warn")}he[t][n][a]=r,e++}}))}))}catch(e){v(`Error constructing finalParamErrors structure: ${e.message}`,"error"),he=null}let pe=null;try{pe=h(e,a,ge,v)}catch(e){v(`Failed to calculate final residuals: ${e.message}`,"error")}let me=null,$e=!1;if(q){v(`Calculating fitted model curves with ${k} points...`,"info"),null!==D&&v(`Confidence interval bands requested (${100*D}%).`,"info");try{const r=m(e,a,ge,k,v,D,ee,ae,W,U,P,se,0,B);if(me=r,L&&null!==D&&r.negativeVarianceEncountered){v("Negative variance detected... Attempting bootstrap fallback...","warn"),$e=!0;const r={maxIterations:w,errorTolerance:N,gradientTolerance:x,linkMap:b,fixMap:M,constraints:E,constraintFunction:A,robustCostFunction:S,epsilon:P,covarianceLambda:J},t=await async function(e,r,t,n,a,i,o,l,s,c,u,f){if(c(`--- Starting Bootstrap CI Calculation (${o} samples) ---`,"info"),!(e&&e.x&&r&&t))return c("Bootstrap Error: Missing primary input data/models/params.","error"),null;if(!o||o<2)return c(`Bootstrap Warning: Invalid numBootstrapSamples (${o}). Must be >= 2. Skipping bootstrap.`,"warn"),null;if(!l||l<=0||l>=1)return c(`Bootstrap Warning: Invalid confidenceLevel (${l}). Skipping bootstrap.`,"warn"),null;if(s<=1)return c(`Bootstrap Warning: Invalid numPointsForCurve (${s}). Skipping bootstrap.`,"warn"),null;const d=e.x.length;if(0===d)return c("Bootstrap Info: No datasets to process.","info"),[];const g=[],h=[];try{const n=m(e,r,t,s,(()=>{}),null,[],null,[],a,0,0,0,f);if(!n||!n.curves)throw new Error(`Failed to calculate original curve shape (result: ${n})`);if(n.curves.length!==d)throw new Error(`Original curve calculation returned ${n.curves.length} curves, but expected ${d}.`);if(n.curves.forEach(((e,r)=>{e&&e.x&&e.y&&e.x.length===s?(h[r]={x:e.x,y:e.y},g[r]=e.x.map((()=>[]))):(c(`Bootstrap Info: Original curve for dataset ${r} is invalid or has wrong length. Skipping this dataset.`,"warn"),h[r]=null,g[r]=null)})),h.every((e=>null===e)))throw new Error("No valid original curves found to base bootstrap on.")}catch(e){return c(`Bootstrap Error getting original curve shape: ${e.message}`,"error"),console.error("Original Curve Shape Error:",e),null}let p=0,y=0;for(y=0;y<o;y++){y>0&&y%50==0&&c(`Bootstrap progress: ${y} / ${o} samples completed...`,"info");const n={x:[],y:[],ye:[]};let a=0;try{for(let r=0;r<d;r++){if(!e.x[r]||0===e.x[r].length){n.x[r]=[],n.y[r]=[],n.ye[r]=[];continue}const t=e.x[r].length,i=Array.from({length:t},(()=>Math.floor(Math.random()*t)));if(!e.y[r]||e.y[r].length!==t||!e.ye[r]||e.ye[r].length!==t)throw new Error(`Inconsistent original data lengths for dataset ${r}.`);n.x[r]=i.map((t=>e.x[r][t])),n.y[r]=i.map((t=>e.y[r][t])),n.ye[r]=i.map((t=>Math.max(1e-9,e.ye[r][t]))),a+=t}if(0===a&&d>0)throw new Error("Bootstrap sample generation resulted in zero total points (all original datasets might be empty).")}catch(e){c(`Bootstrap Warning: Error creating bootstrap sample ${y+1}: ${e.message}. Skipping sample.`,"warn");continue}let i=null;try{if(r.length!==n.x.length)throw new Error(`Internal error: Model function array length (${r.length}) does not match bootstrap data length (${n.x.length}).`);if(i=await $(n,r,t,{...u,calculateFittedModel:{numPoints:s},model_x_range:f,confidenceInterval:null,logLevel:"error"}),i&&i.converged&&!i.error&&i.fittedModelCurves)p++,i.fittedModelCurves.forEach(((e,r)=>{g[r]&&e&&e.y&&e.y.length===g[r].length?e.y.forEach(((e,t)=>{isFinite(e)&&(g[r][t]?g[r][t].push(e):c(`Bootstrap Warning: Target array for collected values missing at ds ${r}, xIdx ${t}.`,"warn"))})):g[r]&&c(`Bootstrap Debug: Curve data mismatch or invalid for dataset ${r} in sample ${y+1}. Expected length ${g[r].length}, Got ${e?.y?.length}.`,"debug")}));else{let e="Unknown";i?i.error?e=`Error property set: ${i.error}`:i.converged?i.fittedModelCurves||(e="Converged but missing fittedModelCurves"):e="Did not converge":e="lmFitGlobal returned null/undefined",c(`Bootstrap sample ${y+1} failed. Reason: ${e}.`,"debug")}}catch(e){c(`Bootstrap Warning: Error during fit for sample ${y+1}: ${e.message}. Skipping sample.`,"warn"),console.error(`Bootstrap Fit ${y+1} Exception:`,e)}}if(c("--- Bootstrap CI Calculation Finished ---","info"),c(`Successful bootstrap samples: ${p} / ${o}`,"info"),p<Math.min(10,.1*o))return c(`Bootstrap Error: Very few successful samples (${p}). Cannot reliably calculate CI bands.`,"error"),h.map((e=>e?{x:e.x,y:e.y}:null)).filter((e=>null!==e));p<.5*o&&c("Bootstrap Warning: Less than 50% of bootstrap samples were successful. Results may be less reliable.","warn");const v=[],w=(1-l)/2,N=1-w;let x=!0;try{c(`Bootstrap Debug: Starting percentile calculation. NumDatasets: ${d}`,"debug");for(let e=0;e<d;e++){if(!h[e]||!g[e]){c(`Bootstrap Debug: Skipping percentile calc for ds ${e} (no original curve or collected values).`,"debug");continue}const r=h[e],t=[],n=[];c(`Bootstrap Debug: Calculating percentiles for ds ${e}, ${r.x.length} points.`,"debug");for(let a=0;a<r.x.length;a++){if(!g[e]||!g[e][a]){c(`Bootstrap Warning: Missing collected y-values array at ds ${e}, xIdx ${a}. Setting bands to NaN.`,"warn"),t.push(NaN),n.push(NaN);continue}const r=g[e][a];if(r&&r.length>=2){const i=r.filter((e=>isFinite(e)));if(i.length<2){c(`Bootstrap Warning: Not enough finite data points (${i.length}) after filtering at ds ${e}, xIdx ${a}. Setting bands to NaN.`,"warn"),t.push(NaN),n.push(NaN);continue}i.sort(((e,r)=>e-r));let o=Math.floor(w*i.length),l=Math.ceil(N*i.length)-1;o=Math.max(0,o),l=Math.min(i.length-1,l),l<o&&(l=o),o<i.length&&l<i.length?(t.push(i[o]),n.push(i[l])):(c(`Bootstrap Warning: Invalid index calculated for percentile at ds ${e}, xIdx ${a} (low:${o}, high:${l}, len:${i.length}). Setting bands to NaN.`,"warn"),t.push(NaN),n.push(NaN))}else c(`Bootstrap Warning: Not enough successful samples (${r?.length}) to calculate percentile at ds ${e}, xIdx ${a}. Setting bands to NaN.`,"warn"),t.push(NaN),n.push(NaN)}v.push({x:r.x,y:r.y,ci_lower:t,ci_upper:n}),c(`Bootstrap Debug: Finished percentiles for ds ${e}.`,"debug")}}catch(e){c(`Bootstrap Error during percentile calculation: ${e.message}`,"error"),console.error("Percentile Calculation Error:",e),x=!1}return x?(c(`Bootstrap Debug: Returning ${v.length} calculated curves.`,"debug"),v):(c("Bootstrap Debug: Returning null due to percentile calculation error.","debug"),null)}(e,a,ge,0,U,0,O,D,k,v,r,B);t?(v("Bootstrap CI calculation completed. Using bootstrap bands.","info"),me={curves:t,negativeVarianceEncountered:!1}):v("Bootstrap CI calculation failed. Retaining standard results.","error")}}catch(e){v(`Failed to calculate fitted model curves: ${e.message}`,"error"),me={curves:null,negativeVarianceEncountered:!1}}}let ye=null;if(o.calculateComponentModels??!1)if(a&&ge)try{ye=function(e,r,t,n,a,i){const o=(e,r)=>{a?a(e,r):console.log(`[${r}] ${e}`)};if(o("Calculating individual component model curves...","info"),!(e&&r&&t&&t.x))return o("Missing required arguments for component curve calculation.","error"),null;if(n<=1)return o(`Invalid numPoints (${n}) for component curve calculation.`,"error"),null;if(e.length!==r.length||e.length!==t.x.length)return o("Structure mismatch between models, params, and data for component curves.","error"),null;const l=[];let s=!0;try{e.forEach(((e,a)=>{if(l[a]=[],!r[a]||!t.x[a])return void o(`Skipping component curves for dataset ${a}: Missing params or x-data.`,"warn");const c=p(t.x[a],i?.[a]??null,a,o);if(null===c)return o(`Invalid X range for dataset ${a}. Skipping component curves.`,"warn"),void(l[a]=new Array(e.length).fill(null));const{min:u,max:f}=c,d=f===u||n<=1?0:(f-u)/(n-1);e.forEach(((e,t)=>{if(!e||"function"!=typeof e)return o(`Skipping component curve for ds ${a}, model ${t}: Invalid model function.`,"warn"),void(l[a][t]=null);if(!r[a][t])return o(`Skipping component curve for ds ${a}, model ${t}: Missing parameters.`,"warn"),void(l[a][t]=null);const i=r[a][t],c={x:[],y:[]};let f=!1;for(let r=0;r<n;r++){const n=0===d?u:u+r*d;let l=NaN;try{const r=e(i,[n]);if(!r||1!==r.length||!isFinite(r[0]))throw new Error(`Component model ${a}-${t} returned invalid result: ${JSON.stringify(r)}`);l=r[0]}catch(e){o(`Error evaluating component model ${a}-${t} at x=${n.toFixed(3)}: ${e.message}`,"error"),l=NaN,f=!0,s=!1}c.x.push(n),c.y.push(l)}f&&o(`Component curve calculation for ds ${a}, model ${t} encountered errors.`,"warn"),l[a][t]=c}))}))}catch(e){return o(`Error processing datasets for component curve calculation: ${e.message}`,"error"),console.error("Component Curve Calculation Error:",e),null}return s?l:null}(a,ge,e,k,v,B),null===ye&&v("Component curve calculation failed or returned null.","warn")}catch(e){v(`Error during component curve calculation: ${e.message}`,"error"),console.error("Component Curve Exception:",e),ye=null}else v("Skipping component curve calculation due to missing models or final parameters.","warn");else v("Component curve calculation not requested.","info");return v("--------------------","info"),v("lmFitGlobal Finished.","info"),v(`Iterations Performed: ${oe}`,"info"),v(`Total Points (N): ${R}`,"info"),v(`Active Parameters (K): ${K}`,"info"),v(`Degrees of Freedom (N-K): ${se}`,"info"),v(`Final Active Parameters: ${ee.map((e=>e.toExponential(5))).join(", ")}`,"info"),v(`Final Chi-Squared: ${re}`,"info"),v(`Reduced Chi-Squared: ${ce}`,"info"),v(`AIC: ${ue}`,"info"),v(`AICc: ${fe}`,"info"),v(`BIC: ${de}`,"info"),v(`Parameter Errors (Active): ${ie.map((e=>isNaN(e)?"NaN":e.toExponential(3))).join(", ")}`,"info"),v(`Converged: ${ne}`,"info"),v("--------------------","info"),{p_active:ee,p_reconstructed:ge,finalParamErrors:he,chiSquared:re,covarianceMatrix:ae,parameterErrors:ie,iterations:oe,converged:ne,activeParamLabels:z,error:null,totalPoints:R,degreesOfFreedom:se,reducedChiSquared:ce,aic:ue,aicc:fe,bic:de,residualsPerSeries:pe,fittedModelCurves:me?.curves??null,bootstrapUsed:$e,fittedModelComponentCurves:ye}}function y(e){return e&&Array.isArray(e.x)&&(0===e.x.length||!Array.isArray(e.x[0]))}function v(e,r,t,n){const a={x:[e.x],y:[e.y],ye:[e.ye]},i=[Array.isArray(r)?r:[r]],o={...n};return!n.fixMap||Array.isArray(n.fixMap[0])&&Array.isArray(n.fixMap[0][0])||(o.fixMap=[n.fixMap]),!n.constraints||Array.isArray(n.constraints[0])&&Array.isArray(n.constraints[0][0])||(o.constraints=[n.constraints]),!n.linkMap||Array.isArray(n.linkMap[0])&&Array.isArray(n.linkMap[0][0])&&Array.isArray(n.linkMap[0][0][0])||(o.linkMap=[n.linkMap]),n.model_x_range&&Array.isArray(n.model_x_range)&&2===n.model_x_range.length?o.model_x_range=[n.model_x_range]:null===n.model_x_range||void 0===n.model_x_range?o.model_x_range=[null]:o.model_x_range=n.model_x_range,{data:a,modelFunction:i,initialParameters:wrappedInitialParams,options:o}}async function w(e,r,t,n={}){if(!y(e))throw new Error("lmFit requires single dataset input format.");const a=Array.isArray(r)?r:[r],{data:i,modelFunction:o,initialParameters:l,options:s}=(1===a.length&&t.length>0&&Array.isArray(t[0]),v(e,a,0,n)),c=await $(i,o,l,s);return c&&!c.error&&(c.fittedModelCurves&&Array.isArray(c.fittedModelCurves)&&(c.fittedModelCurves=c.fittedModelCurves[0]??null),c.fittedModelComponentCurves&&Array.isArray(c.fittedModelComponentCurves)&&(c.fittedModelComponentCurves=c.fittedModelComponentCurves[0]??null),c.residualsPerSeries&&Array.isArray(c.residualsPerSeries)&&(c.residualsPerSeries=c.residualsPerSeries[0]??null),c.p_reconstructed&&Array.isArray(c.p_reconstructed)&&(c.p_reconstructed=c.p_reconstructed[0]??null),c.finalParamErrors&&Array.isArray(c.finalParamErrors)&&(c.finalParamErrors=c.finalParamErrors[0]??null)),c}function N(e=0,r=1){let t=0,n=0;for(;0===t;)t=Math.random();for(;0===n;)n=Math.random();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*n)*r+e}function x(e,r=50){if(e<0)return console.warn(`poissonRandom: lambda cannot be negative (got ${e}). Returning 0.`),0;if(0===e)return 0;if(e>=r){const r=N(e,Math.sqrt(e));return Math.max(0,Math.round(r))}const t=Math.exp(-e);let n=0,a=1;do{n++,a*=Math.random()}while(a>t);return n-1}e.lmFitGlobal=$,e.lmFit=w,e.lmFitIndependent=async function(e,r,t,a={}){if(y(e)){console.warn("lmFitIndependent received single dataset input. Calling lmFit instead.");try{const n=Array.isArray(r)?r:[r],i=1===n.length&&t.length>0&&!Array.isArray(t[0])?t:t[0]??[],o=1===n.length?n[0]:n[0]??[],l={...a};!a.fixMap||!Array.isArray(a.fixMap[0])||Array.isArray(a.fixMap[0][0])&&Array.isArray(a.fixMap[0][0][0])||(l.fixMap=a.fixMap[0]),!a.constraints||!Array.isArray(a.constraints[0])||Array.isArray(a.constraints[0][0])&&Array.isArray(a.constraints[0][0][0])||(l.constraints=a.constraints[0]),!a.linkMap||!Array.isArray(a.linkMap[0])||Array.isArray(a.linkMap[0][0])&&Array.isArray(a.linkMap[0][0][0])||(l.linkMap=a.linkMap[0]);return[await w(e,o,i,l)]}catch(e){return[{error:`Error processing single dataset input for lmFitIndependent: ${e.message}`,converged:!1}]}}const i=e.x?.length??0;if(0===i)return[];if(r?.length!==i||t?.length!==i||e.y?.length!==i||e.ye?.length!==i)throw new Error("Input array lengths must match for lmFitIndependent.");const o=[],l=a.onLog||(()=>{}),s=a.onProgress||(()=>{}),c=n[a.logLevel?.toLowerCase()??"info"]??n.info;for(let u=0;u<i;u++){const i=u,f=(e,r)=>{c>=(n[r]??n.info)&&l(e,r,i)};f(`--- Starting Independent Fit for Dataset ${i} ---`,"info");const d={x:e.x[u],y:e.y[u],ye:e.ye[u]},g=r[u],h=t[u],p={...a};a.fixMap&&Array.isArray(a.fixMap[u])?p.fixMap=a.fixMap[u]:delete p.fixMap,a.constraints&&Array.isArray(a.constraints[u])?p.constraints=a.constraints[u]:delete p.constraints,delete p.linkMap,delete p.onLog,delete p.onProgress,p.onLog=(e,r)=>{l(e,r,i)},p.onProgress=e=>{s(e,i)};const{data:m,modelFunction:y,initialParameters:w,options:N}=v(d,g,0,p);a.model_x_range&&Array.isArray(a.model_x_range)&&a.model_x_range.length>u?p.model_x_range=a.model_x_range[u]:delete p.model_x_range;try{const e=await $(m,y,w,N);o.push(e)}catch(e){f(`Error fitting dataset ${i}: ${e.message}`,"error"),o.push({error:`Fit failed: ${e.message}`,converged:!1,p_active:[],p_reconstructed:h,finalParamErrors:null,chiSquared:NaN,covarianceMatrix:null,parameterErrors:[],iterations:0,activeParamLabels:[],totalPoints:d.x?.length??0,degreesOfFreedom:NaN,reducedChiSquared:NaN,aic:NaN,aicc:NaN,bic:NaN,residualsPerSeries:null,fittedModelCurves:null})}f(`--- Finished Independent Fit for Dataset ${i} ---`,"info")}return o},e.simulateFromParams=function(e,r,t,n={}){const a=n.logFn&&"function"==typeof n.logFn?n.logFn:console.log;try{if(!(e&&r&&t&&Array.isArray(e)&&Array.isArray(r)&&Array.isArray(t)))throw new Error("Missing or invalid required arguments (dataX, modelFunctions, parameters).");const n=e.length;if(r.length!==n||t.length!==n)throw new Error("Input arrays (dataX, modelFunctions, parameters) must have the same outer length.");for(let a=0;a<n;a++){if(!Array.isArray(e[a]))throw new Error(`dataX[${a}] is not an array.`);if(!Array.isArray(r[a]))throw new Error(`modelFunctions[${a}] is not an array.`);if(!Array.isArray(t[a]))throw new Error(`parameters[${a}] is not an array.`);if(r[a].length!==t[a].length)throw new Error(`Mismatch between number of models (${r[a].length}) and parameter groups (${t[a].length}) for dataset ${a}.`)}}catch(e){return a(`Simulation Input Validation Error: ${e.message}`,"error"),null}const i=[],o=e.length,l=n.noiseStdDev??null,s=n.noiseType??null;for(let e=0;e<o;e++){let r=0,t="none";"number"==typeof l&&l>0?r=l:Array.isArray(l)&&"number"==typeof l[e]&&l[e]>0&&(r=l[e]);let n=null;"string"==typeof s?n=s.toLowerCase():Array.isArray(s)&&"string"==typeof s[e]&&(n=s[e].toLowerCase()),"poisson"===n?(t="poisson",r=NaN):t="gaussian"===n?r>0?"gaussian":"none":"none"===n?"none":r>0?"gaussian":"none",i[e]={type:t,stdDev:r},a(`Dataset ${e} Noise: type='${i[e].type}', stdDev=${i[e].stdDev}`,"debug")}const c=[];try{for(let n=0;n<o;n++){const o=e[n],l=r[n],s=t[n],u=i[n],f=[];if(o&&0!==o.length){for(let e=0;e<o.length;e++){const r=o[e];let t=0,i=!0;try{for(let e=0;e<l.length;e++){const a=l[e],i=s[e];if(!a||!i)throw new Error(`Missing function or params for model ${e} in dataset ${n}.`);const o=a(i,[r]);if(!o||1!==o.length||!isFinite(o[0]))throw new Error(`Model ${e} returned non-finite result: ${JSON.stringify(o)}`);t+=o[0]}if(!isFinite(t))throw new Error("Summed y_true is not finite.")}catch(o){a(`Model evaluation error at ds ${n}, point ${e} (x=${r}): ${o.message}. Setting y to NaN.`,"warn"),t=NaN,i=!1}let c=t;if(i)switch(u.type){case"gaussian":c=t+N(0,u.stdDev);break;case"poisson":const i=Math.max(0,t);t<0&&a(`Warning: Clamping negative y_true (${t.toFixed(3)}) to 0 for Poisson noise calculation at ds ${n}, point ${e} (x=${r}).`,"warn"),c=x(i)}else c=NaN;f.push(c)}c.push(f)}else a(`Skipping simulation for empty dataset ${n}.`,"debug"),c.push([])}}catch(e){return a(`Simulation loop error: ${e.message}`,"error"),console.error("Simulation Error Details:",e),null}return{x:e,y:c}}}("undefined"!=typeof window?window:global);
//# sourceMappingURL=globalfit.min.js.map