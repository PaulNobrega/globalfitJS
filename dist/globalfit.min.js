!function(e){"use strict";function r(e){const r=e.map((e=>[...e])),t=r.length;if(0===t)return{u:[],s:[],v:[]};const n=r[0].length;if(0===n)return{u:r.map((()=>[])),s:[],v:[]};t<n&&console.warn("svdDecompose warning: Implementation assumes m >= n. Results may be incorrect.");const a=new Array(n).fill(0),i=Array.from({length:n},(()=>new Array(n).fill(0))),o=new Array(n).fill(0);let s=0,l=0,c=0;for(let e=0;e<n;e++){l=0;for(let n=e;n<t;n++)l+=Math.abs(r[n][e]);if(0!==l){let a=0;for(let n=e;n<t;n++)r[n][e]/=l,a+=r[n][e]*r[n][e];let i=r[e][e];s=-Math.sign(i)*Math.sqrt(a);let o=i*s-a;r[e][e]=i-s;for(let s=e+1;s<n;s++){a=0;for(let n=e;n<t;n++)a+=r[n][e]*r[n][s];i=a/o;for(let n=e;n<t;n++)r[n][s]+=i*r[n][e]}for(let n=e;n<t;n++)r[n][e]*=l}if(a[e]=l*s,s=0,l=0,e<n-1){for(let t=e+1;t<n;t++)l+=Math.abs(r[e][t]);if(0!==l){let a=0;for(let t=e+1;t<n;t++)r[e][t]/=l,a+=r[e][t]*r[e][t];let i=r[e][e+1];s=-Math.sign(i)*Math.sqrt(a);let c=i*s-a;r[e][e+1]=i-s;for(let t=e+1;t<n;t++)o[t]=r[e][t]/c;for(let i=e+1;i<t;i++){a=0;for(let t=e+1;t<n;t++)a+=r[i][t]*r[e][t];for(let t=e+1;t<n;t++)r[i][t]+=a*o[t]}for(let t=e+1;t<n;t++)r[e][t]*=l}}c=Math.max(c,Math.abs(a[e])+Math.abs(s)),o[e]=s}for(let e=n-1;e>=0;e--){if(e<n-1&&0!==o[e])for(let t=e+1;t<n;t++){let a=0;for(let o=e+1;o<n;o++)a+=r[e][o]*i[o][t];a=a/r[e][e+1]/o[e];for(let o=e+1;o<n;o++)i[o][t]+=a*r[e][o]}for(let r=e+1;r<n;r++)i[e][r]=0,i[r][e]=0;i[e][e]=1}const u=Array.from({length:t},(()=>new Array(n).fill(0)));for(let e=n-1;e>=0;e--){let i=e+1;s=a[e];for(let t=i;t<n;t++)r[e][t]=0;if(0!==s){s=1/s;for(let a=i;a<n;a++){let n=0;for(let o=i;o<t;o++)n+=r[o][e]*r[o][a];let o=n/r[e][e]*s;for(let n=e;n<t;n++)r[n][a]+=o*r[n][e]}for(let n=e;n<t;n++)r[n][e]*=s}else for(let n=e;n<t;n++)r[n][e]=0;r[e][e]+=1}for(let e=0;e<t;e++)for(let t=0;t<n;t++)u[e][t]=r[e][t];const f=30*n;for(let e=n-1;e>=0;e--)for(let r=0;r<f;r++){let l=!0,d=e;for(;d>=0;d--){if(0===d||Math.abs(o[d-1])+c===c){l=!1;break}if(Math.abs(a[d-1])+c===c)break}let g=0,h=1;if(l&&d>0)for(let r=d;r<=e;r++){let e=h*o[r];if(o[r]=g*o[r],Math.abs(e)+c===c)break;s=a[r];let n=Math.hypot(e,s);a[r]=n,n=1/n,g=s*n,h=-e*n;for(let e=0;e<t;e++){let t=u[e][d-1],n=u[e][r];u[e][d-1]=t*g+n*h,u[e][r]=n*g-t*h}}let p=a[e];if(d===e){if(p<0){a[e]=-p;for(let r=0;r<n;r++)i[r][e]=-i[r][e]}break}if(r===f-1)throw new Error("svdDecompose error: No convergence after maximum iterations.");let m=a[d],$=a[e-1];s=o[e-1];let y=o[e],v=(($-p)*($+p)+(s-y)*(s+y))/(2*y*$);s=Math.hypot(v,1),v=((m-p)*(m+p)+y*($/(v+(v>=0?1:-1)*s)-y))/m,g=1,h=1;for(let r=d;r<e;r++){let e=r+1;s=o[e],$=a[e],y=h*s,s*=g,p=Math.hypot(v,y),o[r]=p,g=v/p,h=y/p,v=m*g+s*h,s=s*g-m*h,y=$*h,$*=g;for(let t=0;t<n;t++)m=i[t][r],p=i[t][e],i[t][r]=m*g+p*h,i[t][e]=p*g-m*h;p=Math.hypot(v,y),a[r]=p,0!==p&&(p=1/p,g=v*p,h=y*p),v=g*s+h*$,m=g*$-h*s;for(let n=0;n<t;n++)$=u[n][r],p=u[n][e],u[n][r]=$*g+p*h,u[n][e]=p*g-$*h}o[d]=0,o[e]=v,a[e]=m}return{u:u,s:a,v:i}}function t(e,r){const t=e.length;if(0===t)return[];const n=e[0].length,a=r.length;if(0===a)return e.map((e=>[]));const i=r[0].length;if(n!==a)throw new Error(`Matrix dimension mismatch: A(${t}x${n}), B(${a}x${i})`);const o=new Array(t);for(let a=0;a<t;a++){o[a]=new Array(i).fill(0);for(let t=0;t<i;t++)for(let i=0;i<n;i++){if(void 0===e[a]?.[i]||void 0===r[i]?.[t])throw new Error(`Undefined element accessed: A[${a}][${i}] or B[${i}][${t}]`);o[a][t]+=e[a][i]*r[i][t]}}return o}function n(e){const r=e.length;if(0===r)return[];const t=e[0].length;if(0===t)return e.map((()=>[]));const n=new Array(t);for(let a=0;a<t;a++){n[a]=new Array(r);for(let t=0;t<r;t++){if(void 0===e[t]?.[a])throw new Error(`Undefined element accessed during transpose at [${t}][${a}]`);n[a][t]=e[t][a]}}return n}e.LM_SVD_HELPERS={solveLinearSystem:function(e,r){const t=r.length;if(!e||e.length!==t||e.some((e=>!e||e.length!==t)))throw new Error(`Invalid matrix or vector size for solveLinearSystem. Matrix: ${e?.length}x${e?.[0]?.length}, Vector: ${t}`);const n=e.map(((e,t)=>[...e,r[t]]));for(let e=0;e<t;e++){let r=e;for(let a=e+1;a<t;a++)Math.abs(n[a][e])>Math.abs(n[r][e])&&(r=a);if([n[e],n[r]]=[n[r],n[e]],Math.abs(n[e][e])<1e-12){let r=!1;for(let a=e+1;a<t;a++)if(Math.abs(n[a][e])>=1e-12){[n[e],n[a]]=[n[a],n[e]],r=!0;break}if(!r)throw new Error(`Matrix is singular or near-singular during Gaussian elimination at step ${e}.`)}for(let r=e+1;r<t;r++){const a=n[r][e]/n[e][e];if(!isFinite(a))throw new Error(`Non-finite factor encountered during elimination at [${r},${e}]. Pivot: ${n[e][e]}`);n[r][e]=0;for(let i=e+1;i<=t;i++)n[r][i]-=a*n[e][i]}}const a=new Array(t).fill(0);for(let e=t-1;e>=0;e--){if(Math.abs(n[e][e])<1e-12)throw new Error(`Zero pivot encountered during back substitution at step ${e}.`);let r=0;for(let i=e+1;i<t;i++)r+=n[e][i]*a[i];if(a[e]=(n[e][t]-r)/n[e][e],!isFinite(a[e]))throw new Error(`Non-finite solution component encountered at index ${e}. Pivot: ${n[e][e]}`)}return a},svdDecompose:r,multiplyMatrices:t,transposeMatrix:n,invertMatrixUsingSVD:function(e){const a=e.length;if(0===a||e.some((e=>!e||e.length!==a)))throw new Error("Matrix must be square for SVD inversion.");const{u:i,s:o,v:s}=r(e);if(!i||0===i.length||!o||0===o.length||!s||0===s.length)throw new Error("SVD decomposition failed or returned empty matrices.");const l=i[0]?.length,c=o.length,u=s.length,f=s[0]?.length;l===a&&c===a&&u===a&&f===a||console.warn(`SVD returned unexpected dimensions: U(${i.length}x${l}), S(${c}), V(${u}x${f}) for input NxN (${a}x${a})`);const d=new Array(a).fill(0).map((()=>new Array(a).fill(0))),g=Math.min(a,o.length);for(let e=0;e<g;e++)Math.abs(o[e])>1e-10?d[e][e]=1/o[e]:d[e][e]=0;const h=s,p=n(i);if(p.length!==a)throw new Error(`Dimension mismatch for U transpose: Expected ${a} rows, got ${p.length}`);const m=t(h,d),$=t(m,p);return $.length===a&&$[0]?.length===a||console.warn(`SVD inverse resulted in non-square matrix (${$.length}x${$[0]?.length}) for square input (${a}x${a}).`),$}}}("undefined"!=typeof window?window:global),function(e){"use strict";if(!e.LM_SVD_HELPERS)throw new Error("Error: svd.js must be loaded before globalfit.js");const{solveLinearSystem:r,invertMatrixUsingSVD:t}=e.LM_SVD_HELPERS,n={none:0,error:1,warn:2,info:3,debug:4};const a=1e-14;function i(e){const r=[.9999999999998099,676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,1.5056327351493116e-7];if(e<=0)return 1/0;if(e<.5)return Math.log(Math.PI/Math.sin(Math.PI*e))-i(1-e);const t=e-1;let n=r[0];const a=t+7+.5;for(let e=1;e<r.length;e++)n+=r[e]/(t+e);return(t+.5)*Math.log(a)-a+Math.log(Math.sqrt(2*Math.PI)*n)}function o(e,r,t){let n=1,i=n,o=0,s=0,l=0;do{l++;const c=l-1,u=2*c;let f=(r+u)*(r+u+1),d=0===f?0:-(r+c)*(r+t+c)*e/f,g=0;if(c>0){let n=(r+u-1)*(r+u);g=0===n?0:c*(t-c)*e/n}if(o=1+d*o,Math.abs(o)<a&&(o=a),i=1+d/i,Math.abs(i)<a&&(i=a),o=1/o,s=i*o,n*=s,c>0&&(o=1+g*o,Math.abs(o)<a&&(o=a),i=1+g/i,Math.abs(i)<a&&(i=a),o=1/o,s=i*o,n*=s),Math.abs(s-1)<a)break}while(l<150);return l>=150&&console.warn("_jstat_ibeta_cont_frac: Failed to converge."),n}function s(e,r,t){if(e<0||e>1||r<=0||t<=0)return NaN;if(0===e)return 0;if(1===e)return 1;const n=i(r)+i(t)-i(r+t),a=r*Math.log(e)+t*Math.log(1-e),s=Math.exp(a-n);return e<(r+1)/(r+t+2)?s*o(e,r,t)/r:1-s*o(1-e,t,r)/t}function l(e,r){if(e<0||e>1||r<=0||!isFinite(r))return NaN;if(0===e)return-1/0;if(1===e)return 1/0;if(.5===e)return 0;let t=function(e,r,t){if(e<0||e>1||r<=0||t<=0)return NaN;if(0===e)return 0;if(1===e)return 1;const n=1e-12;let a=0,o=1,l=.5,c=.5;l=e<.5?Math.pow(e*r*Math.exp(i(r)+i(t)-i(r+t)),1/r):1-Math.pow((1-e)*t*Math.exp(i(r)+i(t)-i(r+t)),1/t),l<=0&&(l=n),l>=1&&(l=1-n);const u=i(r)+i(t)-i(r+t);for(let i=0;i<100;i++){const i=s(l,r,t)-e;let f=(r-1)*Math.log(l)+(t-1)*Math.log(1-l)-u,d=Math.exp(f);c=0!==d&&isFinite(d)?i/d:i>0?-1e-11:1e-11;let g=l-c;if(i>0?o=l:a=l,(g<=a||g>=o)&&(g=(a+o)/2,c=l-g),l=g,Math.abs(c)<n||Math.abs(i)<n)return l}return console.warn(`_jstat_ibeta_inv: Failed to converge. p=${e}, a=${r}, b=${t}. Est: ${l}`),l}(e<.5?2*e:2*(1-e),.5*r,.5);if(isNaN(t)||0===t)return e<.5?-1/0:1/0;if(1===t)return 0;let n=r*(1-t)/t;if(n<0)return console.warn(`_jstat_studentt_inv: Negative t_squared (${n}).`),NaN;let a=Math.sqrt(n);return e<.5?-a:a}function c(e,r){const t=e.length;if(0===t)return[];const n=e[0]?.length??0;if(0===n&&0===r.length)return[];if(0===n&&r.length>0)throw new Error("Jacobian has zero columns but residuals exist.");if(t!==r.length)throw new Error(`Jacobian rows (${t}) must match residuals length (${r.length}).`);const a=new Array(n).fill(0);for(let i=0;i<n;i++)for(let n=0;n<t;n++){if(void 0===e[n]?.[i]||!isFinite(e[n][i])||void 0===r[n]||!isFinite(r[n]))throw new Error(`Invalid value in gradient calculation at point ${n}, param ${i}.`);a[i]+=e[n][i]*r[n]}return a}function u(e){const r=e.length;if(0===r)return[];const t=e[0]?.length??0;if(0===t)return[];const n=new Array(t).fill(0).map((()=>new Array(t).fill(0)));for(let a=0;a<t;a++)for(let i=a;i<t;i++){let t=0;for(let n=0;n<r;n++){if(void 0===e[n]?.[a]||!isFinite(e[n][a])||void 0===e[n]?.[i]||!isFinite(e[n][i]))throw new Error(`Invalid value in Hessian calculation at point ${n}, params ${a}, ${i}.`);t+=e[n][a]*e[n][i]}n[a][i]=t,a!==i&&(n[i][a]=t)}return n}function f(e,r,t,n,a,i,o){const s=t(n);let l=0;return e.x.forEach(((t,n)=>{const i=e.y[n],c=e.ye[n],u=r[n],f=s[n];if(!(t&&i&&c&&u&&f&&t.length===i.length&&t.length===c.length))return o(`Data length/param mismatch dataset ${n}`,"error"),NaN;for(let e=0;e<t.length;e++){0;const r=t[e],s=i[e],d=c[e];if(0===d){o(`Zero error point ${e} ds ${n}. Skipping.`,"warn");continue}if(!isFinite(s)||!isFinite(d)){o(`Non-finite y/ye point ${e} ds ${n}. Skipping.`,"warn");continue}let g=0;try{u.forEach(((e,t)=>{if(!f[t])throw new Error(`Missing params ds ${n}, pIdx ${t}.`);const a=e(f[t],[r]);if(!a||1!==a.length||!isFinite(a[0]))throw new Error(`Model ${n}-${t} invalid result x=${r}: ${JSON.stringify(a)}`);g+=a[0]}))}catch(r){return o(`Error evaluating model ds ${n}, pt ${e}: ${r.message}`,"error"),NaN}if(!isFinite(g)){o(`Non-finite model value pt ${e} ds ${n}. Skipping.`,"warn");continue}const h=(s-g)/d;l+=1===a?Math.abs(h):2===a?Math.log(1+h*h*.5):h*h}})),isFinite(l)?l:(o("Non-finite chi-squared calculated.","error"),1/0)}function d(e,r,t,n,a,i,o,s){const l=t(n),c=[],u=[],f=a.length;if(e.x.forEach(((a,o)=>{const d=e.y[o],g=e.ye[o],h=r[o],p=l[o];if(!(a&&d&&g&&h&&p&&a.length===d.length&&a.length===g.length))throw new Error(`Data length mismatch ds ${o} Jacobian.`);for(let e=0;e<a.length;e++){0;const r=a[e],l=d[e],m=g[e];if(0===m)throw new Error(`Zero error pt ${e} ds ${o} Jacobian.`);if(!isFinite(l)||!isFinite(m))throw new Error(`Non-finite y/ye pt ${e} ds ${o} Jacobian.`);let $=0;try{h.forEach(((e,t)=>{if(!p[t])throw new Error(`Missing params ds ${o}, pIdx ${t} (Jacobian orig).`);const n=e(p[t],[r]);if(!n||1!==n.length||!isFinite(n[0]))throw new Error(`Model ${o}-${t} invalid result x=${r}: ${JSON.stringify(n)}`);$+=n[0]}))}catch(r){throw s(`Error evaluating model (orig) ds ${o}, pt ${e}: ${r.message}`,"error"),r}if(!isFinite($))throw new Error(`Non-finite orig model value pt ${e} ds ${o}.`);const y=(l-$)/m;c.push(y);const v=new Array(f).fill(0);for(let a=0;a<f;a++){const l=[...n],c=l[a];let u=i*Math.abs(c)+i;0===u&&(u=i),l[a]+=u;const f=t(l);let d=0,g=!1;try{const e=f[o];h.forEach(((t,n)=>{if(g)return;if(!e||!e[n])throw new Error(`Missing params ds ${o}, pIdx ${n} (Jacobian pert).`);const a=t(e[n],[r]);if(!a||1!==a.length||!isFinite(a[0]))return s(`Model ${o}-${n} invalid result during perturbation x=${r}`,"warn"),void(g=!0);d+=a[0]}))}catch(r){s(`Error evaluating model (pert) ds ${o}, pt ${e}, actP ${a}: ${r.message}`,"error"),g=!0}if(g||!isFinite(d))s(`Non-finite/failed pert model value pt ${e}, ds ${o}, actP ${a}. Deriv=0.`,"warn"),v[a]=0;else{const e=(d-$)/u;v[a]=-e/m}isFinite(v[a])||(s(`Non-finite Jacobian element pt ${e}, ds ${o}, actP ${a}. Setting=0.`,"warn"),v[a]=0)}u.push(v)}})),c.length!==u.length)throw new Error(`Internal error: Residuals (${c.length}) != Jacobian rows (${u.length})`);if(u.length>0&&u[0].length!==f)throw new Error(`Internal error: Jacobian cols (${u[0].length}) != active params (${f})`);return{jacobian:u,residuals:c}}function g(e,r,t,n,a,i){let o=e,s=!1,l=!1;if(r){let a=null;n.forEach(((n,i)=>{r[i]&&n.forEach(((n,o)=>{if(r[i][o])for(let c=0;c<n;c++){const n=r[i]?.[o]?.[c];if(n){a||(a=JSON.parse(JSON.stringify(e)));let r=a[i][o][c];const u=r;if(void 0!==n.min&&r<n.min&&(r=n.min),void 0!==n.max&&r>n.max&&(r=n.max),r!==u){a[i][o][c]=r,l=!0;t.some((e=>e.originalCoord[0][0]===i&&e.originalCoord[0][1]===o&&e.originalCoord[1]===c))&&(s=!0)}}}}))})),a&&(o=a)}if("function"==typeof a)try{const r=l?o:e,t=l?null:JSON.stringify(r);if(o=a(r),!Array.isArray(o)||o.length!==n.length)throw new Error("Constraint function did not return a valid parameter structure.");const c=JSON.stringify(o);l||c===t?l&&c!==JSON.stringify(r)&&(s=!0,i("Custom constraint function modified parameters after box constraints.","debug")):(s=!0,i("Custom constraint function modified parameters.","debug"))}catch(r){i(`Error executing custom constraint function: ${r.message}`,"error"),o=l?JSON.parse(JSON.stringify(e)):e}return{constrainedParams:o,changedActive:s}}function h(e,r,t,n){if(!(e&&e.x&&e.y&&e.ye&&r&&t))return n("Missing data/models/params for final residual calculation.","error"),null;const a=[];let i=!1;return e.x.forEach(((o,s)=>{const l=e.y[s],c=e.ye[s],u=r[s],f=t[s],d=[];if(!(l&&c&&u&&f&&o.length===l.length&&o.length===c.length))return n(`Inconsistent data/model/params for dataset ${s} in final residual calculation. Skipping.`,"warn"),void a.push([]);for(let e=0;e<o.length;e++){const r=o[e],t=l[e],a=c[e];if(0===a||!isFinite(t)||!isFinite(a)){n(`Invalid data/error at point ${e} in dataset ${s} for final residuals. Storing NaN.`,"warn"),d.push(NaN);continue}let g=0,h=!1;try{u.forEach(((e,t)=>{if(!f[t])throw new Error(`Missing params for model ${t}.`);const n=e(f[t],[r]);if(!n||1!==n.length||!isFinite(n[0]))throw new Error(`Model ${s}-${t} returned invalid result.`);g+=n[0]}))}catch(r){n(`Error evaluating model for final residual at ds ${s}, pt ${e}: ${r.message}`,"error"),h=!0,i=!0}h||!isFinite(g)?d.push(NaN):d.push((t-g)/a)}a.push(d)})),i?null:a}function p(e,r,t,n,a,i,o,s,c,u,f,d,g){if(!(e&&e.x&&r&&t&&Array.isArray(t)))return a("Missing or invalid primary arguments for fitted curve calculation.","error"),{curves:null,negativeVarianceEncountered:!1};if(n<=1)return a(`Invalid numPoints (${n}) for fitted curve calculation.`,"error"),{curves:null,negativeVarianceEncountered:!1};null!==i&&("number"!=typeof i||i<=0||i>=1)&&(a(`Invalid confidenceLevel (${i}) passed internally.`,"warn"),i=null);let h=!1,p=!1;const m=[],$=o?.length??0,y=null!==i&&o&&$>0&&s&&Array.isArray(s)&&s.length===$&&s[0]?.length===$&&d>0&&isFinite(d)&&c&&Array.isArray(c)&&c.length===$&&"function"==typeof u&&isFinite(f)&&f>0;null===i||y||a("Standard CI calculation prerequisites not met. Skipping standard CI calculation.","warn");try{e.x.forEach(((e,c)=>{if(!(e&&Array.isArray(e)&&r[c]&&t[c]))return a(`Skipping dataset ${c}: Missing data, model, or params.`,"warn"),void m.push(null);const g=r[c],v=t[c],w={x:[],y:[],ci_lower:[],ci_upper:[]};let N=y,x=NaN;if(N){x=function(e,r,t){if(r<=0)return t(`Cannot calculate t-value: Degrees of freedom (${r}) must be positive.`,"warn"),NaN;if(e<=0||e>=1)return t(`Cannot calculate t-value: Cumulative probability (${e}) must be between 0 and 1.`,"warn"),NaN;try{const n=l(e,r);return isFinite(n)?n:(t(`Calculated t-value is not finite (${n}) for p=${e}, dof=${r}.`,"warn"),NaN)}catch(e){return t(`Error calculating t-value: ${e.message}`,"error"),NaN}}(1-(1-i)/2,d,a),isNaN(x)&&(a(`Failed to calculate critical t-value for dataset ${c}. Skipping CI calculation.`),N=!1)}let b=1/0,M=-1/0;if(e.length>0){b=e[0],M=e[0];for(let r=1;r<e.length;++r)e[r]<b&&(b=e[r]),e[r]>M&&(M=e[r])}if(!isFinite(b)||!isFinite(M)||e.length>0&&M<b)return a(`Invalid or empty X range [${b}, ${M}] for dataset ${c}. Skipping curve calculation.`,"warn"),void m.push(null);0===e.length&&(b=M=0);const E=M===b||n<=1?0:(M-b)/(n-1);for(let e=0;e<n;e++){const r=0===E?b:b+e*E;let t=0,n=!1,i=NaN,l=NaN;try{if(g.forEach(((e,n)=>{if(!v[n])throw new Error(`Missing params for model ${n}.`);const a=e(v[n],[r]);if(!a||1!==a.length||!isFinite(a[0]))throw new Error(`Model ${c}-${n} returned invalid result.`);t+=a[0]})),!isFinite(t))throw new Error("Calculated y value is not finite.")}catch(e){a(`Error evaluating model for fitted curve at ds ${c}, x=${r.toFixed(3)}: ${e.message}`,"error"),n=!0,h=!0,t=NaN}if(N&&isFinite(t))try{const e=new Array($).fill(0);for(let n=0;n<$;n++){const i=[...o],s=i[n];let l=f*Math.abs(s)+f;0===l&&(l=f),i[n]+=l;const d=u(i)[c];let h=0,p=!1;try{if(g.forEach(((e,t)=>{if(p)return;if(!d||!d[t])throw new Error(`Missing perturbed params ds ${c}, pIdx ${t}.`);const n=e(d[t],[r]);n&&1===n.length&&isFinite(n[0])?h+=n[0]:p=!0})),p||!isFinite(h))throw new Error("Perturbed model evaluation failed or yielded non-finite result.")}catch(e){a(`Error evaluating perturbed model (ds ${c}, x=${r.toFixed(3)}, actP ${n}): ${e.message}. Derivative set to 0.`,"warn"),p=!0}e[n]=p?0:(h-t)/l,isFinite(e[n])||(a(`Non-finite model Jacobian element (ds ${c}, x=${r.toFixed(3)}, actP ${n}). Setting to 0.`,"warn"),e[n]=0)}let n=0;for(let r=0;r<$;r++)for(let t=0;t<$;t++){if(!s[r]||!isFinite(s[r][t]))throw new Error(`Invalid covariance matrix element Cov[${r}][${t}]: ${s[r]?.[t]}`);if(!isFinite(e[r])||!isFinite(e[t]))throw new Error("Non-finite Jacobian element encountered during variance calculation.");n+=e[r]*s[r][t]*e[t]}if(!isFinite(n))throw new Error(`Calculated variance is not finite (${n}).`);n<0&&(a(`Warning: Calculated variance for CI at x=${r.toFixed(3)} is negative (${n.toExponential(3)}). Using absolute value for SE.`),p=!0,n=Math.abs(n));const d=Math.sqrt(n);if(!isFinite(d))throw new Error("Calculated standard error is not finite.");const h=x*d;i=t-h,l=t+h,isFinite(i)&&isFinite(l)||(a(`Non-finite CI bound calculated at x=${r.toFixed(3)}. Setting to NaN.`),i=NaN,l=NaN)}catch(e){a(`Error calculating standard confidence interval at ds ${c}, x=${r.toFixed(3)}: ${e.message}`,"error"),i=NaN,l=NaN}w.x.push(r),w.y.push(t),N&&(w.ci_lower.push(i),w.ci_upper.push(l))}N&&w.ci_lower.length>0?m.push(w):m.push({x:w.x,y:w.y})}))}catch(e){return a(`Error processing datasets for curve calculation: ${e.message}`,"error"),{curves:null,negativeVarianceEncountered:p}}const v=m.filter((e=>null!==e));return{curves:v.length>0?v:null,negativeVarianceEncountered:p}}async function m(e,a,i,o={}){const s=o.onLog&&"function"==typeof o.onLog?o.onLog:()=>{},l=o.logLevel??"info",$=n[l.toLowerCase()]??n.info,y=(e,r)=>{$>=(n[r]??n.info)&&s(e,r)},v=o.maxIterations??100,w=o.errorTolerance??1e-6,N=o.gradientTolerance??1e-6,x=o.linkMap??null,b=o.fixMap??null,M=o.constraints??null,E=o.constraintFunction??null,S=o.robustCostFunction??null;let F=o.lambdaInitial??.001;const A=o.lambdaIncreaseFactor??10,I=o.lambdaDecreaseFactor??10,C=o.epsilon??1e-8,P=o.calculateFittedModel??!1,k="object"==typeof P&&P.numPoints>1?P.numPoints:300,q=!0===P||"object"==typeof P,J=o.covarianceLambda??1e-9,L=o.bootstrapFallback??!0,O=o.numBootstrapSamples??200;let _=null;null!==o.confidenceInterval&&void 0!==o.confidenceInterval&&("number"==typeof o.confidenceInterval&&o.confidenceInterval>0&&o.confidenceInterval<1?_=o.confidenceInterval:y(`Invalid confidenceInterval option (${o.confidenceInterval}). Must be a number between 0 and 1 (exclusive). Confidence intervals will not be calculated.`,"warn")),y("Starting lmFitGlobal (v1.2.6 - Added CI Bands)...");let D=0;e&&e.x&&e.x.forEach((e=>{Array.isArray(e)?D+=e.length:y("Non-array in data.x.","warn")})),y(`Total data points (N): ${D}`);const B={p_active:[],p_reconstructed:i,finalParamErrors:null,chiSquared:NaN,covarianceMatrix:null,parameterErrors:null,iterations:0,converged:!1,activeParamLabels:[],totalPoints:D,degreesOfFreedom:NaN,reducedChiSquared:NaN,aic:NaN,aicc:NaN,bic:NaN,residualsPerSeries:null,fittedModelCurves:null};if(0===D){const e="No data points.";return y(e,"error"),{...B,error:e}}let R;try{R=function(e,r,t,n){n("--- Running setupParameterMapping (New linkMap structure v1.4.3 logic) ---","debug"),n("Received linkMapInput (structure like fixMap): "+(r?"Provided":"Null"),"debug"),n(`Received fixMapInput: ${JSON.stringify(t)}`,"debug");const a=[],i=[],o=[],s=t?JSON.parse(JSON.stringify(t)):[],l=r?JSON.parse(JSON.stringify(r)):null;e.forEach(((e,r)=>{a.push([]),s[r]||(s[r]=[]),e.forEach(((e,t)=>{a[r].push(e.length),s[r][t]||(s[r][t]=new Array(e.length).fill(!1)),e.forEach(((e,n)=>{i.push(e),o.push([[r,t],n]),s[r][t].length<=n&&(s[r][t][n]=!1)}))}))}));const c=i.length,u=new Array(c).fill(-1),f=new Array(c).fill(!1),d=[],g=[],h=[];o.forEach(((e,r)=>{const[[t,n],a]=e;!0===s[t]?.[n]?.[a]&&(f[r]=!0)})),n(`Initial isFixed array (after fixMap): ${JSON.stringify(f)}`,"debug");const p={};l?(l.forEach(((r,t)=>{!r||t>=e.length||r.forEach(((r,a)=>{!r||a>=e[t].length||r.forEach(((r,i)=>{if(!(i>=e[t][a].length)&&null!=r&&""!==r){const e=[t,a,i],s=o.findIndex((r=>r[0][0]===e[0]&&r[0][1]===e[1]&&r[1]===e[2]));-1!==s?(p[r]||(p[r]=[]),p[r].push(s)):n(`Could not find flat index for link coordinate [${e.join(", ")}]`,"warn")}}))}))})),n(`Collected Link Groups by ID: ${JSON.stringify(p)}`,"debug"),Object.entries(p).forEach((([e,r])=>{if(r.length<2)return void n(`Link Group ${e} has only one member (${r[0]}). Ignoring link.`,"debug");n(`Processing Link Group ${e}: Flat indices ${JSON.stringify(r)}`,"debug");let t=-1,a=null,s=!0;for(const i of r)i<0||i>=c?n(`  Invalid flat index ${i} found in link group ${e}. Skipping.`,"warn"):f[i]||(s=!1,-1===t&&(t=i,a=o[i]));if(s){if(t=r[0],t<0||t>=c)return void n(`  Invalid nominal master index ${t} for fixed group ${e}. Skipping group.`,"warn");n(`  Link Group ${e} consists entirely of initially fixed parameters. Nominal master: flat index ${t}`,"debug"),f[t]||(n(`  Marking nominal master ${JSON.stringify(o[t])} (flat ${t}) as fixed because entire group is fixed.`,"debug"),f[t]=!0),r.forEach((e=>{e<0||e>=c||(e!==t?(u[e]=t,i[e]=i[t],n(`    Linked fixed slave ${JSON.stringify(o[e])} (flat ${e}) to fixed master ${t}. State: isFixed=${f[e]}, masterMap=${u[e]}`,"debug")):n(`    Nominal Master ${JSON.stringify(o[e])} (flat ${e}). State: isFixed=${f[e]}, masterMap=${u[e]}`,"debug"))}))}else-1!==t?(n(`  Link Group ${e} master: ${JSON.stringify(a)} (flat index ${t})`,"debug"),n(`    Master ${JSON.stringify(o[t])} (flat ${t}). State: isFixed=${f[t]}, masterMap=${u[t]}`,"debug"),r.forEach((e=>{if(!(e<0||e>=c)&&e!==t){const r=f[e];f[e]&&(n(`    Linking overrides fixed status for ${JSON.stringify(o[e])} (flat ${e}).`,"warn"),f[e]=!1),u[e]=t,i[e]=i[t],n(`    Linked slave ${JSON.stringify(o[e])} (flat ${e}) to master ${t}. InitialFixed=${r}. Final State: isFixed=${f[e]}, masterMap=${u[e]}`,"debug")}}))):n(`  Internal Logic Error: Could not determine master type for group ${e}.`,"error")}))):n("No linkMap provided or linkMap is null.","debug"),n(`Final isFixed array (after linking): ${JSON.stringify(f)}`,"debug"),n(`Final masterMap array: ${JSON.stringify(u)}`,"debug");let m=0;for(let e=0;e<c;e++)if(!f[e]&&-1===u[e]){d.push({originalCoord:o[e],flatIndex:e,activeIndex:m}),g.push(i[e]);const[[r,t],n]=o[e];h.push(`ds${r}_p${t}_v${n}`),m++}const $=g.length;return n(`Identified ${$} active parameters: ${JSON.stringify(h)}`,"debug"),n(`Active Initial Params: ${JSON.stringify(g)}`,"debug"),{activeInitialParams:g,reconstructParams:e=>{if(e.length!==$)throw new Error(`reconstructParams expects ${$} params, received ${e.length}`);const r=[...i];d.forEach(((t,n)=>{if(n>=e.length)throw new Error("Mismatch activeParamInfo/activeParams.");r[t.flatIndex]=e[n]}));for(let e=0;e<c;e++)if(-1!==u[e]){if(u[e]<0||u[e]>=r.length)throw new Error(`Master index ${u[e]} out of bounds.`);r[e]=r[u[e]]}const t=[];let o=0;return a.forEach(((e,n)=>{t[n]=[],e.forEach(((e,a)=>{t[n][a]=[];for(let i=0;i<e;i++){if(o>=r.length)throw new Error(`Flat index ${o} out of bounds.`);t[n][a][i]=r[o],o++}}))})),o!==c&&n(`Param reconstruction mismatch: ${o} vs ${c}`,"warn"),t},activeParamInfo:d,totalActiveParams:$,paramStructure:a,activeParamLabels:h,isFixed:f,masterMap:u,paramCoordinates:o,nTotalParams:c}}(i,x,b,y)}catch(e){const r=`Parameter setup failed: ${e.message}`;return y(r,"error"),{...B,error:r}}const{activeInitialParams:j,reconstructParams:V,activeParamInfo:G,totalActiveParams:U,paramStructure:W,activeParamLabels:T}=R,H=U,{isFixed:z,masterMap:K,paramCoordinates:X,nTotalParams:Z}=function(e,r,t){const n=[],a=[];let i=0;const o=t?JSON.parse(JSON.stringify(t)):[],s=r?JSON.parse(JSON.stringify(r)):null;e.forEach(((e,r)=>{n.push([]),o[r]||(o[r]=[]),e.forEach(((e,t)=>{n[r].push(e.length),o[r][t]||(o[r][t]=new Array(e.length).fill(!1)),e.forEach(((e,n)=>{a.push([[r,t],n]),o[r][t].length<=n&&(o[r][t][n]=!1),i++}))}))}));const l=i,c=new Array(l).fill(-1),u=new Array(l).fill(!1);a.forEach(((e,r)=>{const[[t,n],a]=e;!0===o[t]?.[n]?.[a]&&(u[r]=!0)}));const f={};return s&&(s.forEach(((r,t)=>{!r||t>=e.length||r.forEach(((r,n)=>{!r||n>=e[t].length||r.forEach(((r,i)=>{if(!(i>=e[t][n].length)&&null!=r&&""!==r){const e=[t,n,i],o=a.findIndex((r=>r[0][0]===e[0]&&r[0][1]===e[1]&&r[1]===e[2]));-1!==o&&(f[r]||(f[r]=[]),f[r].push(o))}}))}))})),Object.values(f).forEach((e=>{if(e.length<2)return;let r=-1,t=!0;for(const n of e)n<0||n>=l||u[n]||(t=!1,-1===r&&(r=n));if(t){if(r=e[0],r<0||r>=l)return;u[r]||(u[r]=!0),e.forEach((e=>{e<0||e>=l||e!==r&&(c[e]=r)}))}else-1!==r&&e.forEach((e=>{e<0||e>=l||e!==r&&(u[e]&&(u[e]=!1),c[e]=r)}))}))),{isFixed:u,masterMap:c,paramCoordinates:a,nTotalParams:l,paramStructure:n}}(i,x,b);if(0===H){y("No active parameters to fit. Calculating initial stats.","warn");let r=NaN,t=D,n=NaN,i=NaN,o=NaN,s=NaN,l=null,c=null,u=null;const d=V([]);try{r=f(e,a,V,[],S,0,y),l=h(e,a,d,y),q&&(c=p(e,a,d,k,y,null,[],null,[],V,C,t)),u=[];let g=0;W.forEach(((e,r)=>{u[r]=[],e.forEach(((e,t)=>{u[r][t]=[];for(let n=0;n<e;n++)u[r][t][n]=0,g++}))})),isFinite(r)&&t>0?(n=r/t,i=r,s=r,o=D>1?i:1/0):isFinite(r)&&(n=1/0,i=r,s=r,o=1/0,y("Degrees of freedom is zero or negative. Reduced ChiSq and AICc are Infinity.","warn"))}catch(e){y(`Error calculating initial ChiSq/Residuals: ${e.message}`,"error")}return{p_active:[],p_reconstructed:d,finalParamErrors:u,chiSquared:r,covarianceMatrix:[],parameterErrors:[],iterations:0,converged:!0,activeParamLabels:[],totalPoints:D,degreesOfFreedom:t,reducedChiSquared:n,aic:i,aicc:o,bic:s,error:null,residualsPerSeries:l,fittedModelCurves:c}}let Q=[...j],Y=NaN;try{Y=f(e,a,V,Q,S,0,y)}catch(e){const r=`Initial Chi-Squared calculation failed: ${e.message}`;return y(r,"error"),{...B,p_reconstructed:V(Q),error:r}}let ee,re=!1,te=null,ne=[],ae=0,ie=null;if(y(`Total active parameters (K): ${H}`,"info"),y(`Active Parameter Labels: ${T.join(", ")}`,"info"),y(`Initial Active Parameters: ${Q.map((e=>e.toExponential(3))).join(", ")}`,"info"),y(`Initial Chi-Squared: ${Y}`,"info"),!isFinite(Y)){const e="Initial Chi-Squared is not finite.";return y("Non-finite initial Chi-Squared.","error"),{...B,p_reconstructed:V(Q),chiSquared:Y,error:e}}for(ee=0;ee<v;ee++){let t,n,i,s;ae=ee+1,y(`--- Iteration ${ae} (Lambda: ${F.toExponential(3)}) ---`,"info"),y(`Iter ${ae} - Current Active Params: ${Q.map((e=>e.toExponential(5))).join(", ")}`,"debug");try{({jacobian:t,residuals:n}=d(e,a,V,Q,G,C,0,y))}catch(e){const r=`Jacobian failed: ${e.message}`;return y(`Error Jacobian/Resid iter ${ae}: ${r}`,"error"),{...B,p_reconstructed:V(Q),chiSquared:Y,iterations:ae,error:r}}try{i=c(t,n),s=u(t)}catch(e){const r=`Grad/Hess failed: ${e.message}`;return y(`Error Grad/Hess iter ${ae}: ${r}`,"error"),{...B,p_reconstructed:V(Q),chiSquared:Y,iterations:ae,error:r}}if(i.some((e=>!isFinite(e)))||s.some((e=>e.some((e=>!isFinite(e)))))){const e="Non-finite grad/hess.";return y(`Non-finite grad/hess iter ${ae}.`,"error"),{...B,p_reconstructed:V(Q),chiSquared:Y,iterations:ae,error:e}}const l=Math.max(...i.map(Math.abs));if(l<N){y(`Converged (grad tol ${N}). Max Grad: ${l.toExponential(3)}`,"info"),re=!0;break}let h;y(`Gradient: ${i.map((e=>e.toExponential(3))).join(", ")}`,"info");let p=!1,m=0;const $=5;let v=F;for(;!p&&m<$;){const e=s.map(((e,r)=>e.map(((e,t)=>r===t?e+v:e))));try{const t=i.map((e=>-e));if(h=r(e,t),h.some((e=>!isFinite(e))))throw new Error("NaN/Inf in updates.");p=!0}catch(e){if(m++,y(`Solve failed (Att ${m}/${$}, Iter ${ae}): ${e.message}. Inc lambda.`,"warn"),v=Math.min(v*A*(m>1?A:1),1e10),y(`Attempting solve with Lambda: ${v.toExponential(3)}`,"info"),m>=$){const e="Failed solve.";return y(`Failed solve after ${$} attempts.`,"error"),{...B,p_reconstructed:V(Q),chiSquared:Y,iterations:ae,error:e}}}}if(!p)continue;F=v,y(`Parameter Updates: ${h.map((e=>e.toExponential(3))).join(", ")}`,"info");const x=Q.map(((e,r)=>e+h[r]));let b=V(x);const{constrainedParams:P,changedActive:k}=g(b,M,G,W,E,y);b=P;const q=k?G.map((e=>b[e.originalCoord[0][0]][e.originalCoord[0][1]][e.originalCoord[1]])):x;let J=NaN;try{J=f(e,a,V,q,S,0,y)}catch(e){y(`Error ChiSq proposed step iter ${ae}: ${e.message}`,"error"),J=1/0}if(y(`New Chi-Squared: ${J}`,"info"),isFinite(J)&&J<Y){const e=Y-J;Q=q,Y=J,F=Math.max(F/I,1e-12),y(`Accepted. ChiSq decreased by ${e.toExponential(3)}. Lambda decreased to: ${F.toExponential(3)}`,"info");try{o.onProgress?.({iteration:ae,chiSquared:Y,lambda:F,activeParameters:[...Q]})}catch(e){y(`Error in onProgress callback: ${e.message}`,"warn")}if(e<w){y(`Converged (chiSq tol ${w}).`,"info"),re=!0;break}}else F=Math.min(F*A,1e10),y(`Rejected (ChiSq ${isNaN(J)?"NaN":"increased/stagnant"}). Lambda increased to: ${F.toExponential(3)}`,"info"),F>=1e10&&y("Lambda reached maximum limit.","warn")}re||ee!==v||y(`lmFitGlobal did not converge within ${v} iterations.`,"warn"),y("Recalculating final Jacobian/Hessian for covariance...","info");try{const{jacobian:r}=d(e,a,V,Q,G,C,0,y);ie=u(r)}catch(e){y(`Failed to recalculate final Hessian: ${e.message}`,"error"),ie=null}let oe=NaN,se=NaN,le=NaN,ce=NaN,ue=NaN;if(isFinite(Y)&&D>0)if(oe=D-H,oe>0){se=Y/oe,le=Y+2*H;const e=D-H-1;e>0?ce=le+2*H*(H+1)/e:(ce=1/0,y("AICc denominator (N-K-1) is zero or negative. AICc set to Infinity.","warn")),ue=Y+H*Math.log(D)}else se=1/0,le=Y+2*H,ue=Y+H*Math.log(D),ce=1/0,y(`Degrees of freedom (${oe}) is zero or negative. Reduced Chi-Squared is Infinity/undefined. Parameter errors may be unreliable or NaN.`,"warn");else y("Final Chi-Squared is not finite. Cannot calculate statistics reliably.","warn"),oe=D-H,se=NaN,le=NaN,ce=NaN,ue=NaN;if(ne=new Array(H).fill(NaN),te=null,ie&&H>0)try{const e=ie.map(((e,r)=>e.map(((e,t)=>r===t?e+J:e))));y(`Applying regularization (lambda=${J}) for covariance matrix inversion.`,"debug"),te=t(e);const r=se&&isFinite(se)&&se>0?se:1;1===r&&oe>0&&isFinite(Y)?y("Reduced Chi-Squared is invalid or not positive. Using scale factor 1.0 for parameter errors, which might underestimate errors if fit is poor.","warn"):1===r&&oe<=0&&y("Using scale factor 1.0 for parameter errors due to non-positive degrees of freedom.","info"),ne=te.map(((e,t)=>{if(t>=e.length)return y(`Error accessing covariance matrix diagonal at index ${t}. Matrix might be malformed.`,"error"),NaN;const n=e[t],a=n*r;let i=NaN;return isFinite(a)&&(a<0?(y(`Negative variance (${a.toExponential(3)}) encountered for active param ${t}. Returning sqrt(abs(variance)). Error estimate might be unreliable.`,"warn"),i=Math.sqrt(Math.abs(a))):i=Math.sqrt(a)),isNaN(i)&&isFinite(a)&&y(`NaN error calc for param ${t}: variance=${n}, scaleFactor=${r}, scaledVariance=${a}`,"debug"),i})),ne.some(isNaN)&&y("NaN encountered in parameter errors (potentially due to non-finite variance/covariance). Check fit quality, model, initial parameters, and data.","warn")}catch(e){y(`Failed to calculate covariance matrix/parameter errors: ${e.message}`,"error"),ne=new Array(H).fill(NaN),te=new Array(H).fill(0).map((()=>new Array(H).fill(NaN)))}else H>0&&!ie?y("Could not calculate covariance matrix (no valid final Hessian?). Parameter errors will be NaN.","warn"):0===H&&y("No active parameters (K=0). Parameter errors are not applicable.","info"),te=new Array(H).fill(0).map((()=>new Array(H).fill(NaN)));const fe=V(Q);let de=null;try{de=[];let e=0;W.forEach(((r,t)=>{de[t]=[],r.forEach(((r,n)=>{de[t][n]=[];for(let a=0;a<r;a++){let r=NaN;if(z[e])r=0;else if(-1!==K[e]){const t=K[e],n=G.find((e=>e.flatIndex===t));n?ne&&n.activeIndex<ne.length?r=ne[n.activeIndex]:(y(`Invalid index ${n.activeIndex} for parameterErrors array (length ${ne?.length}) while processing slave ${e}. Setting error to NaN.`,"warn"),r=NaN):(y(`Could not find active info for master parameter (flat index ${t}) of slave (flat index ${e}). Setting error to 0.`,"warn"),r=0)}else{const t=G.find((r=>r.flatIndex===e));t?ne&&t.activeIndex<ne.length?r=ne[t.activeIndex]:(y(`Invalid index ${t.activeIndex} for parameterErrors array (length ${ne?.length}) while processing active param ${e}. Setting error to NaN.`,"warn"),r=NaN):y(`Could not find active info for supposedly active parameter at flat index ${e}. Setting error to NaN.`,"warn")}de[t][n][a]=r,e++}}))}))}catch(e){y(`Error constructing finalParamErrors structure: ${e.message}`,"error"),de=null}let ge=null;try{ge=h(e,a,fe,y)}catch(e){y(`Failed to calculate final residuals: ${e.message}`,"error")}let he=null,pe=!1,me=!1;if(q){y(`Calculating fitted model curves with ${k} points...`,"info"),null!==_&&y(`Confidence interval bands requested (${100*_}%).`,"info");try{const r=p(e,a,fe,k,y,_,Q,te,G,V,C,oe);if(he=r.curves,pe=r.negativeVarianceEncountered,L&&null!==_&&pe){y("Negative variance detected... Attempting bootstrap fallback...","warn"),me=!0;const r={maxIterations:v,errorTolerance:w,gradientTolerance:N,linkMap:x,fixMap:b,constraints:M,constraintFunction:E,robustCostFunction:S,epsilon:C,covarianceLambda:J},t=await async function(e,r,t,n,a,i,o,s,l,c,u){if(c(`--- Starting Bootstrap CI Calculation (${o} samples) ---`,"info"),!(e&&e.x&&r&&t))return c("Bootstrap Error: Missing primary input data/models/params.","error"),null;if(!o||o<2)return c(`Bootstrap Warning: Invalid numBootstrapSamples (${o}). Must be >= 2. Skipping bootstrap.`,"warn"),null;if(!s||s<=0||s>=1)return c(`Bootstrap Warning: Invalid confidenceLevel (${s}). Skipping bootstrap.`,"warn"),null;if(l<=1)return c(`Bootstrap Warning: Invalid numPointsForCurve (${l}). Skipping bootstrap.`,"warn"),null;const f=e.x.length;if(0===f)return c("Bootstrap Info: No datasets to process.","info"),[];const d=[],g=[];try{const n=p(e,r,t,l,(()=>{}),null,[],null,[],a,0,0);if(!n||!n.curves)throw new Error(`Failed to calculate original curve shape (result: ${n})`);if(n.curves.length!==f)throw new Error(`Original curve calculation returned ${n.curves.length} curves, but expected ${f}.`);if(n.curves.forEach(((e,r)=>{e&&e.x&&e.y&&e.x.length===l?(g[r]={x:e.x,y:e.y},d[r]=e.x.map((()=>[]))):(c(`Bootstrap Info: Original curve for dataset ${r} is invalid or has wrong length. Skipping this dataset.`,"warn"),g[r]=null,d[r]=null)})),g.every((e=>null===e)))throw new Error("No valid original curves found to base bootstrap on.")}catch(e){return c(`Bootstrap Error getting original curve shape: ${e.message}`,"error"),console.error("Original Curve Shape Error:",e),null}let h=0,$=0;const y={...u,confidenceInterval:null,calculateFittedModel:{numPoints:l},logLevel:"error",onLog:(e,r)=>{"error"!==r&&"warn"!==r||c(`Bootstrap Fit [Sample ${$+1}] ${r.toUpperCase()}: ${e}`,"warn")},onProgress:()=>{}};for($=0;$<o;$++){$>0&&$%50==0&&c(`Bootstrap progress: ${$} / ${o} samples completed...`,"info");const n={x:[],y:[],ye:[]};let a=0;try{for(let r=0;r<f;r++){if(!e.x[r]||0===e.x[r].length){n.x[r]=[],n.y[r]=[],n.ye[r]=[];continue}const t=e.x[r].length,i=Array.from({length:t},(()=>Math.floor(Math.random()*t)));if(!e.y[r]||e.y[r].length!==t||!e.ye[r]||e.ye[r].length!==t)throw new Error(`Inconsistent original data lengths for dataset ${r}.`);n.x[r]=i.map((t=>e.x[r][t])),n.y[r]=i.map((t=>e.y[r][t])),n.ye[r]=i.map((t=>Math.max(1e-9,e.ye[r][t]))),a+=t}if(0===a&&f>0)throw new Error("Bootstrap sample generation resulted in zero total points (all original datasets might be empty).")}catch(e){c(`Bootstrap Warning: Error creating bootstrap sample ${$+1}: ${e.message}. Skipping sample.`,"warn");continue}let i=null;try{if(r.length!==n.x.length)throw new Error(`Internal error: Model function array length (${r.length}) does not match bootstrap data length (${n.x.length}).`);if(i=await m(n,r,t,y),i&&i.converged&&!i.error&&i.fittedModelCurves)h++,i.fittedModelCurves.forEach(((e,r)=>{d[r]&&e&&e.y&&e.y.length===d[r].length?e.y.forEach(((e,t)=>{isFinite(e)&&(d[r][t]?d[r][t].push(e):c(`Bootstrap Warning: Target array for collected values missing at ds ${r}, xIdx ${t}.`,"warn"))})):d[r]&&c(`Bootstrap Debug: Curve data mismatch or invalid for dataset ${r} in sample ${$+1}. Expected length ${d[r].length}, Got ${e?.y?.length}.`,"debug")}));else{let e="Unknown";i?i.error?e=`Error property set: ${i.error}`:i.converged?i.fittedModelCurves||(e="Converged but missing fittedModelCurves"):e="Did not converge":e="lmFitGlobal returned null/undefined",c(`Bootstrap sample ${$+1} failed. Reason: ${e}.`,"debug")}}catch(e){c(`Bootstrap Warning: Error during fit for sample ${$+1}: ${e.message}. Skipping sample.`,"warn"),console.error(`Bootstrap Fit ${$+1} Exception:`,e)}}if(c("--- Bootstrap CI Calculation Finished ---","info"),c(`Successful bootstrap samples: ${h} / ${o}`,"info"),h<Math.min(10,.1*o))return c(`Bootstrap Error: Very few successful samples (${h}). Cannot reliably calculate CI bands.`,"error"),g.map((e=>e?{x:e.x,y:e.y}:null)).filter((e=>null!==e));h<.5*o&&c("Bootstrap Warning: Less than 50% of bootstrap samples were successful. Results may be less reliable.","warn");const v=[],w=(1-s)/2,N=1-w;let x=!0;try{c(`Bootstrap Debug: Starting percentile calculation. NumDatasets: ${f}`,"debug");for(let e=0;e<f;e++){if(!g[e]||!d[e]){c(`Bootstrap Debug: Skipping percentile calc for ds ${e} (no original curve or collected values).`,"debug");continue}const r=g[e],t=[],n=[];c(`Bootstrap Debug: Calculating percentiles for ds ${e}, ${r.x.length} points.`,"debug");for(let a=0;a<r.x.length;a++){if(!d[e]||!d[e][a]){c(`Bootstrap Warning: Missing collected y-values array at ds ${e}, xIdx ${a}. Setting bands to NaN.`,"warn"),t.push(NaN),n.push(NaN);continue}const r=d[e][a];if(r&&r.length>=2){const i=r.filter((e=>isFinite(e)));if(i.length<2){c(`Bootstrap Warning: Not enough finite data points (${i.length}) after filtering at ds ${e}, xIdx ${a}. Setting bands to NaN.`,"warn"),t.push(NaN),n.push(NaN);continue}i.sort(((e,r)=>e-r));let o=Math.floor(w*i.length),s=Math.ceil(N*i.length)-1;o=Math.max(0,o),s=Math.min(i.length-1,s),s<o&&(s=o),o<i.length&&s<i.length?(t.push(i[o]),n.push(i[s])):(c(`Bootstrap Warning: Invalid index calculated for percentile at ds ${e}, xIdx ${a} (low:${o}, high:${s}, len:${i.length}). Setting bands to NaN.`,"warn"),t.push(NaN),n.push(NaN))}else c(`Bootstrap Warning: Not enough successful samples (${r?.length}) to calculate percentile at ds ${e}, xIdx ${a}. Setting bands to NaN.`,"warn"),t.push(NaN),n.push(NaN)}v.push({x:r.x,y:r.y,ci_lower:t,ci_upper:n}),c(`Bootstrap Debug: Finished percentiles for ds ${e}.`,"debug")}}catch(e){c(`Bootstrap Error during percentile calculation: ${e.message}`,"error"),console.error("Percentile Calculation Error:",e),x=!1}return x?(c(`Bootstrap Debug: Returning ${v.length} calculated curves.`,"debug"),v):(c("Bootstrap Debug: Returning null due to percentile calculation error.","debug"),null)}(e,a,fe,0,V,0,O,_,k,y,r);t?(y("Bootstrap CI calculation completed. Using bootstrap bands.","info"),he=t):y("Bootstrap CI calculation failed. Retaining standard results.","error")}}catch(e){y(`Failed to calculate fitted model curves: ${e.message}`,"error"),he=null}}let $e=null;if(o.calculateComponentModels??!1)if(a&&fe)try{$e=function(e,r,t,n,a){const i=(e,r)=>{a?a(e,r):console.log(`[${r}] ${e}`)};if(i("Calculating individual component model curves...","info"),!(e&&r&&t&&t.x))return i("Missing required arguments for component curve calculation.","error"),null;if(n<=1)return i(`Invalid numPoints (${n}) for component curve calculation.`,"error"),null;if(e.length!==r.length||e.length!==t.x.length)return i("Structure mismatch between models, params, and data for component curves.","error"),null;const o=[];let s=!0;try{e.forEach(((e,a)=>{if(o[a]=[],!r[a]||!t.x[a])return void i(`Skipping component curves for dataset ${a}: Missing params or x-data.`,"warn");const l=t.x[a];let c=1/0,u=-1/0;if(l.length>0&&(c=Math.min(...l),u=Math.max(...l)),!isFinite(c)||!isFinite(u)||l.length>0&&u<c)return void i(`Invalid or empty X range [${c}, ${u}] for dataset ${a}. Skipping component curves.`,"warn");0===l.length&&(c=u=0);const f=u===c||n<=1?0:(u-c)/(n-1);e.forEach(((e,t)=>{if(!e||"function"!=typeof e)return i(`Skipping component curve for ds ${a}, model ${t}: Invalid model function.`,"warn"),void(o[a][t]=null);if(!r[a][t])return i(`Skipping component curve for ds ${a}, model ${t}: Missing parameters.`,"warn"),void(o[a][t]=null);const l=r[a][t],u={x:[],y:[]};let d=!1;for(let r=0;r<n;r++){const n=0===f?c:c+r*f;let o=NaN;try{const r=e(l,[n]);if(!r||1!==r.length||!isFinite(r[0]))throw new Error(`Component model ${a}-${t} returned invalid result: ${JSON.stringify(r)}`);o=r[0]}catch(e){i(`Error evaluating component model ${a}-${t} at x=${n.toFixed(3)}: ${e.message}`,"error"),o=NaN,d=!0,s=!1}u.x.push(n),u.y.push(o)}d&&i(`Component curve calculation for ds ${a}, model ${t} encountered errors.`,"warn"),o[a][t]=u}))}))}catch(e){return i(`Error processing datasets for component curve calculation: ${e.message}`,"error"),console.error("Component Curve Calculation Error:",e),null}return s?o:null}(a,fe,e,k,y),null===$e&&y("Component curve calculation failed or returned null.","warn")}catch(e){y(`Error during component curve calculation: ${e.message}`,"error"),console.error("Component Curve Exception:",e),$e=null}else y("Skipping component curve calculation due to missing models or final parameters.","warn");else y("Component curve calculation not requested.","info");return y("--------------------","info"),y("lmFitGlobal Finished.","info"),y(`Iterations Performed: ${ae}`,"info"),y(`Total Points (N): ${D}`,"info"),y(`Active Parameters (K): ${H}`,"info"),y(`Degrees of Freedom (N-K): ${oe}`,"info"),y(`Final Active Parameters: ${Q.map((e=>e.toExponential(5))).join(", ")}`,"info"),y(`Final Chi-Squared: ${Y}`,"info"),y(`Reduced Chi-Squared: ${se}`,"info"),y(`AIC: ${le}`,"info"),y(`AICc: ${ce}`,"info"),y(`BIC: ${ue}`,"info"),y(`Parameter Errors (Active): ${ne.map((e=>isNaN(e)?"NaN":e.toExponential(3))).join(", ")}`,"info"),y(`Converged: ${re}`,"info"),y("--------------------","info"),{p_active:Q,p_reconstructed:fe,finalParamErrors:de,chiSquared:Y,covarianceMatrix:te,parameterErrors:ne,iterations:ae,converged:re,activeParamLabels:T,error:null,totalPoints:D,degreesOfFreedom:oe,reducedChiSquared:se,aic:le,aicc:ce,bic:ue,residualsPerSeries:ge,fittedModelCurves:he,bootstrapUsed:me,fittedModelComponentCurves:$e}}function $(e){return e&&Array.isArray(e.x)&&(0===e.x.length||!Array.isArray(e.x[0]))}function y(e,r,t,n){const a={x:[e.x],y:[e.y],ye:[e.ye]},i=[Array.isArray(r)?r:[r]],o={...n};return!n.fixMap||Array.isArray(n.fixMap[0])&&Array.isArray(n.fixMap[0][0])||(o.fixMap=[n.fixMap]),!n.constraints||Array.isArray(n.constraints[0])&&Array.isArray(n.constraints[0][0])||(o.constraints=[n.constraints]),!n.linkMap||Array.isArray(n.linkMap[0])&&Array.isArray(n.linkMap[0][0])&&Array.isArray(n.linkMap[0][0][0])||(o.linkMap=[n.linkMap]),{data:a,modelFunction:i,initialParameters:wrappedInitialParams,options:o}}async function v(e,r,t,n={}){if(!$(e))throw new Error("lmFit requires single dataset input format.");const a=Array.isArray(r)?r:[r],{data:i,modelFunction:o,initialParameters:s,options:l}=(1===a.length&&t.length>0&&Array.isArray(t[0]),y(e,a,0,n));return await m(i,o,s,l)}function w(e=0,r=1){let t=0,n=0;for(;0===t;)t=Math.random();for(;0===n;)n=Math.random();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*n)*r+e}function N(e,r=50){if(e<0)return console.warn(`poissonRandom: lambda cannot be negative (got ${e}). Returning 0.`),0;if(0===e)return 0;if(e>=r){const r=w(e,Math.sqrt(e));return Math.max(0,Math.round(r))}const t=Math.exp(-e);let n=0,a=1;do{n++,a*=Math.random()}while(a>t);return n-1}e.lmFitGlobal=m,e.lmFit=v,e.lmFitIndependent=async function(e,r,t,a={}){if($(e)){console.warn("lmFitIndependent received single dataset input. Calling lmFit instead.");try{const n=Array.isArray(r)?r:[r],i=1===n.length&&t.length>0&&!Array.isArray(t[0])?t:t[0]??[],o=1===n.length?n[0]:n[0]??[],s={...a};!a.fixMap||!Array.isArray(a.fixMap[0])||Array.isArray(a.fixMap[0][0])&&Array.isArray(a.fixMap[0][0][0])||(s.fixMap=a.fixMap[0]),!a.constraints||!Array.isArray(a.constraints[0])||Array.isArray(a.constraints[0][0])&&Array.isArray(a.constraints[0][0][0])||(s.constraints=a.constraints[0]),!a.linkMap||!Array.isArray(a.linkMap[0])||Array.isArray(a.linkMap[0][0])&&Array.isArray(a.linkMap[0][0][0])||(s.linkMap=a.linkMap[0]);return[await v(e,o,i,s)]}catch(e){return[{error:`Error processing single dataset input for lmFitIndependent: ${e.message}`,converged:!1}]}}const i=e.x?.length??0;if(0===i)return[];if(r?.length!==i||t?.length!==i||e.y?.length!==i||e.ye?.length!==i)throw new Error("Input array lengths must match for lmFitIndependent.");const o=[],s=a.onLog||(()=>{}),l=a.onProgress||(()=>{}),c=n[a.logLevel?.toLowerCase()??"info"]??n.info;for(let u=0;u<i;u++){const i=u,f=(e,r)=>{c>=(n[r]??n.info)&&s(e,r,i)};f(`--- Starting Independent Fit for Dataset ${i} ---`,"info");const d={x:e.x[u],y:e.y[u],ye:e.ye[u]},g=r[u],h=t[u],p={...a};a.fixMap&&Array.isArray(a.fixMap[u])?p.fixMap=a.fixMap[u]:delete p.fixMap,a.constraints&&Array.isArray(a.constraints[u])?p.constraints=a.constraints[u]:delete p.constraints,delete p.linkMap,delete p.onLog,delete p.onProgress,p.onLog=(e,r)=>{s(e,r,i)},p.onProgress=e=>{l(e,i)};const{data:$,modelFunction:v,initialParameters:w,options:N}=y(d,g,0,p);try{const e=await m($,v,w,N);o.push(e)}catch(e){f(`Error fitting dataset ${i}: ${e.message}`,"error"),o.push({error:`Fit failed: ${e.message}`,converged:!1,p_active:[],p_reconstructed:h,finalParamErrors:null,chiSquared:NaN,covarianceMatrix:null,parameterErrors:[],iterations:0,activeParamLabels:[],totalPoints:d.x?.length??0,degreesOfFreedom:NaN,reducedChiSquared:NaN,aic:NaN,aicc:NaN,bic:NaN,residualsPerSeries:null,fittedModelCurves:null})}f(`--- Finished Independent Fit for Dataset ${i} ---`,"info")}return o},e.simulateFromParams=function(e,r,t,n={}){const a=n.logFn&&"function"==typeof n.logFn?n.logFn:console.log;try{if(!(e&&r&&t&&Array.isArray(e)&&Array.isArray(r)&&Array.isArray(t)))throw new Error("Missing or invalid required arguments (dataX, modelFunctions, parameters).");const n=e.length;if(r.length!==n||t.length!==n)throw new Error("Input arrays (dataX, modelFunctions, parameters) must have the same outer length.");for(let a=0;a<n;a++){if(!Array.isArray(e[a]))throw new Error(`dataX[${a}] is not an array.`);if(!Array.isArray(r[a]))throw new Error(`modelFunctions[${a}] is not an array.`);if(!Array.isArray(t[a]))throw new Error(`parameters[${a}] is not an array.`);if(r[a].length!==t[a].length)throw new Error(`Mismatch between number of models (${r[a].length}) and parameter groups (${t[a].length}) for dataset ${a}.`)}}catch(e){return a(`Simulation Input Validation Error: ${e.message}`,"error"),null}const i=[],o=e.length,s=n.noiseStdDev??null,l=n.noiseType??null;for(let e=0;e<o;e++){let r=0,t="none";"number"==typeof s&&s>0?r=s:Array.isArray(s)&&"number"==typeof s[e]&&s[e]>0&&(r=s[e]);let n=null;"string"==typeof l?n=l.toLowerCase():Array.isArray(l)&&"string"==typeof l[e]&&(n=l[e].toLowerCase()),"poisson"===n?(t="poisson",r=NaN):t="gaussian"===n?r>0?"gaussian":"none":"none"===n?"none":r>0?"gaussian":"none",i[e]={type:t,stdDev:r},a(`Dataset ${e} Noise: type='${i[e].type}', stdDev=${i[e].stdDev}`,"debug")}const c=[];try{for(let n=0;n<o;n++){const o=e[n],s=r[n],l=t[n],u=i[n],f=[];if(o&&0!==o.length){for(let e=0;e<o.length;e++){const r=o[e];let t=0,i=!0;try{for(let e=0;e<s.length;e++){const a=s[e],i=l[e];if(!a||!i)throw new Error(`Missing function or params for model ${e} in dataset ${n}.`);const o=a(i,[r]);if(!o||1!==o.length||!isFinite(o[0]))throw new Error(`Model ${e} returned non-finite result: ${JSON.stringify(o)}`);t+=o[0]}if(!isFinite(t))throw new Error("Summed y_true is not finite.")}catch(o){a(`Model evaluation error at ds ${n}, point ${e} (x=${r}): ${o.message}. Setting y to NaN.`,"warn"),t=NaN,i=!1}let c=t;if(i)switch(u.type){case"gaussian":c=t+w(0,u.stdDev);break;case"poisson":const i=Math.max(0,t);t<0&&a(`Warning: Clamping negative y_true (${t.toFixed(3)}) to 0 for Poisson noise calculation at ds ${n}, point ${e} (x=${r}).`,"warn"),c=N(i)}else c=NaN;f.push(c)}c.push(f)}else a(`Skipping simulation for empty dataset ${n}.`,"debug"),c.push([])}}catch(e){return a(`Simulation loop error: ${e.message}`,"error"),console.error("Simulation Error Details:",e),null}return{x:e,y:c}}}("undefined"!=typeof window?window:global);
//# sourceMappingURL=globalfit.min.js.map