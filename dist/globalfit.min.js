!function(e){"use strict";function t(e){const t=e.map((e=>[...e])),r=t.length;if(0===r)return{u:[],s:[],v:[]};const n=t[0].length;if(0===n)return{u:t.map((()=>[])),s:[],v:[]};r<n&&console.warn("svdDecompose warning: Implementation assumes m >= n. Results may be incorrect.");const a=new Array(n).fill(0),i=Array.from({length:n},(()=>new Array(n).fill(0))),o=new Array(n).fill(0);let s=0,l=0,c=0;for(let e=0;e<n;e++){l=0;for(let n=e;n<r;n++)l+=Math.abs(t[n][e]);if(0!==l){let a=0;for(let n=e;n<r;n++)t[n][e]/=l,a+=t[n][e]*t[n][e];let i=t[e][e];s=-Math.sign(i)*Math.sqrt(a);let o=i*s-a;t[e][e]=i-s;for(let s=e+1;s<n;s++){a=0;for(let n=e;n<r;n++)a+=t[n][e]*t[n][s];i=a/o;for(let n=e;n<r;n++)t[n][s]+=i*t[n][e]}for(let n=e;n<r;n++)t[n][e]*=l}if(a[e]=l*s,s=0,l=0,e<n-1){for(let r=e+1;r<n;r++)l+=Math.abs(t[e][r]);if(0!==l){let a=0;for(let r=e+1;r<n;r++)t[e][r]/=l,a+=t[e][r]*t[e][r];let i=t[e][e+1];s=-Math.sign(i)*Math.sqrt(a);let c=i*s-a;t[e][e+1]=i-s;for(let r=e+1;r<n;r++)o[r]=t[e][r]/c;for(let i=e+1;i<r;i++){a=0;for(let r=e+1;r<n;r++)a+=t[i][r]*t[e][r];for(let r=e+1;r<n;r++)t[i][r]+=a*o[r]}for(let r=e+1;r<n;r++)t[e][r]*=l}}c=Math.max(c,Math.abs(a[e])+Math.abs(s)),o[e]=s}for(let e=n-1;e>=0;e--){if(e<n-1&&0!==o[e])for(let r=e+1;r<n;r++){let a=0;for(let o=e+1;o<n;o++)a+=t[e][o]*i[o][r];a=a/t[e][e+1]/o[e];for(let o=e+1;o<n;o++)i[o][r]+=a*t[e][o]}for(let t=e+1;t<n;t++)i[e][t]=0,i[t][e]=0;i[e][e]=1}const f=Array.from({length:r},(()=>new Array(n).fill(0)));for(let e=n-1;e>=0;e--){let i=e+1;s=a[e];for(let r=i;r<n;r++)t[e][r]=0;if(0!==s){s=1/s;for(let a=i;a<n;a++){let n=0;for(let o=i;o<r;o++)n+=t[o][e]*t[o][a];let o=n/t[e][e]*s;for(let n=e;n<r;n++)t[n][a]+=o*t[n][e]}for(let n=e;n<r;n++)t[n][e]*=s}else for(let n=e;n<r;n++)t[n][e]=0;t[e][e]+=1}for(let e=0;e<r;e++)for(let r=0;r<n;r++)f[e][r]=t[e][r];const d=30*n;for(let e=n-1;e>=0;e--)for(let t=0;t<d;t++){let l=!0,u=e;for(;u>=0;u--){if(0===u||Math.abs(o[u-1])+c===c){l=!1;break}if(Math.abs(a[u-1])+c===c)break}let h=0,g=1;if(l&&u>0)for(let t=u;t<=e;t++){let e=g*o[t];if(o[t]=h*o[t],Math.abs(e)+c===c)break;s=a[t];let n=Math.hypot(e,s);a[t]=n,n=1/n,h=s*n,g=-e*n;for(let e=0;e<r;e++){let r=f[e][u-1],n=f[e][t];f[e][u-1]=r*h+n*g,f[e][t]=n*h-r*g}}let m=a[e];if(u===e){if(m<0){a[e]=-m;for(let t=0;t<n;t++)i[t][e]=-i[t][e]}break}if(t===d-1)throw new Error("svdDecompose error: No convergence after maximum iterations.");let p=a[u],$=a[e-1];s=o[e-1];let w=o[e],y=(($-m)*($+m)+(s-w)*(s+w))/(2*w*$);s=Math.hypot(y,1),y=((p-m)*(p+m)+w*($/(y+(y>=0?1:-1)*s)-w))/p,h=1,g=1;for(let t=u;t<e;t++){let e=t+1;s=o[e],$=a[e],w=g*s,s*=h,m=Math.hypot(y,w),o[t]=m,h=y/m,g=w/m,y=p*h+s*g,s=s*h-p*g,w=$*g,$*=h;for(let r=0;r<n;r++)p=i[r][t],m=i[r][e],i[r][t]=p*h+m*g,i[r][e]=m*h-p*g;m=Math.hypot(y,w),a[t]=m,0!==m&&(m=1/m,h=y*m,g=w*m),y=h*s+g*$,p=h*$-g*s;for(let n=0;n<r;n++)$=f[n][t],m=f[n][e],f[n][t]=$*h+m*g,f[n][e]=m*h-$*g}o[u]=0,o[e]=y,a[e]=p}return{u:f,s:a,v:i}}function r(e,t){const r=e.length;if(0===r)return[];const n=e[0].length,a=t.length;if(0===a)return e.map((e=>[]));const i=t[0].length;if(n!==a)throw new Error(`Matrix dimension mismatch: A(${r}x${n}), B(${a}x${i})`);const o=new Array(r);for(let a=0;a<r;a++){o[a]=new Array(i).fill(0);for(let r=0;r<i;r++)for(let i=0;i<n;i++){if(void 0===e[a]?.[i]||void 0===t[i]?.[r])throw new Error(`Undefined element accessed: A[${a}][${i}] or B[${i}][${r}]`);o[a][r]+=e[a][i]*t[i][r]}}return o}function n(e){const t=e.length;if(0===t)return[];const r=e[0].length;if(0===r)return e.map((()=>[]));const n=new Array(r);for(let a=0;a<r;a++){n[a]=new Array(t);for(let r=0;r<t;r++){if(void 0===e[r]?.[a])throw new Error(`Undefined element accessed during transpose at [${r}][${a}]`);n[a][r]=e[r][a]}}return n}e.LM_SVD_HELPERS={solveLinearSystem:function(e,t){const r=t.length;if(!e||e.length!==r||e.some((e=>!e||e.length!==r)))throw new Error(`Invalid matrix or vector size for solveLinearSystem. Matrix: ${e?.length}x${e?.[0]?.length}, Vector: ${r}`);const n=e.map(((e,r)=>[...e,t[r]]));for(let e=0;e<r;e++){let t=e;for(let a=e+1;a<r;a++)Math.abs(n[a][e])>Math.abs(n[t][e])&&(t=a);if([n[e],n[t]]=[n[t],n[e]],Math.abs(n[e][e])<1e-12){let t=!1;for(let a=e+1;a<r;a++)if(Math.abs(n[a][e])>=1e-12){[n[e],n[a]]=[n[a],n[e]],t=!0;break}if(!t)throw new Error(`Matrix is singular or near-singular during Gaussian elimination at step ${e}.`)}for(let t=e+1;t<r;t++){const a=n[t][e]/n[e][e];if(!isFinite(a))throw new Error(`Non-finite factor encountered during elimination at [${t},${e}]. Pivot: ${n[e][e]}`);n[t][e]=0;for(let i=e+1;i<=r;i++)n[t][i]-=a*n[e][i]}}const a=new Array(r).fill(0);for(let e=r-1;e>=0;e--){if(Math.abs(n[e][e])<1e-12)throw new Error(`Zero pivot encountered during back substitution at step ${e}.`);let t=0;for(let i=e+1;i<r;i++)t+=n[e][i]*a[i];if(a[e]=(n[e][r]-t)/n[e][e],!isFinite(a[e]))throw new Error(`Non-finite solution component encountered at index ${e}. Pivot: ${n[e][e]}`)}return a},svdDecompose:t,multiplyMatrices:r,transposeMatrix:n,invertMatrixUsingSVD:function(e){const a=e.length;if(0===a||e.some((e=>!e||e.length!==a)))throw new Error("Matrix must be square for SVD inversion.");const{u:i,s:o,v:s}=t(e);if(!i||0===i.length||!o||0===o.length||!s||0===s.length)throw new Error("SVD decomposition failed or returned empty matrices.");const l=i[0]?.length,c=o.length,f=s.length,d=s[0]?.length;l===a&&c===a&&f===a&&d===a||console.warn(`SVD returned unexpected dimensions: U(${i.length}x${l}), S(${c}), V(${f}x${d}) for input NxN (${a}x${a})`);const u=new Array(a).fill(0).map((()=>new Array(a).fill(0))),h=Math.min(a,o.length);for(let e=0;e<h;e++)Math.abs(o[e])>1e-10?u[e][e]=1/o[e]:u[e][e]=0;const g=s,m=n(i);if(m.length!==a)throw new Error(`Dimension mismatch for U transpose: Expected ${a} rows, got ${m.length}`);const p=r(g,u),$=r(p,m);return $.length===a&&$[0]?.length===a||console.warn(`SVD inverse resulted in non-square matrix (${$.length}x${$[0]?.length}) for square input (${a}x${a}).`),$}}}("undefined"!=typeof window?window:global),function(e){"use strict";if(!e.LM_SVD_HELPERS)throw new Error("Error: svd.js must be loaded before fit.js");const{solveLinearSystem:t,invertMatrixUsingSVD:r}=e.LM_SVD_HELPERS,n={none:0,error:1,warn:2,info:3,debug:4};function a(e,t){const r=e.length;if(0===r)return[];const n=e[0]?.length??0;if(0===n&&0===t.length)return[];if(0===n&&t.length>0)throw new Error("Jacobian has zero columns but residuals exist.");if(r!==t.length)throw new Error(`Jacobian rows (${r}) must match residuals length (${t.length}).`);const a=new Array(n).fill(0);for(let i=0;i<n;i++)for(let n=0;n<r;n++){if(void 0===e[n]?.[i]||!isFinite(e[n][i])||void 0===t[n]||!isFinite(t[n]))throw new Error(`Invalid value in gradient calculation at point ${n}, param ${i}.`);a[i]+=e[n][i]*t[n]}return a}function i(e){const t=e.length;if(0===t)return[];const r=e[0]?.length??0;if(0===r)return[];const n=new Array(r).fill(0).map((()=>new Array(r).fill(0)));for(let a=0;a<r;a++)for(let i=a;i<r;i++){let r=0;for(let n=0;n<t;n++){if(void 0===e[n]?.[a]||!isFinite(e[n][a])||void 0===e[n]?.[i]||!isFinite(e[n][i]))throw new Error(`Invalid value in Hessian calculation at point ${n}, params ${a}, ${i}.`);r+=e[n][a]*e[n][i]}n[a][i]=r,a!==i&&(n[i][a]=r)}return n}function o(e,t,r,n,a,i,o){const s=r(n);let l=0;return e.x.forEach(((r,n)=>{const i=e.y[n],c=e.ye[n],f=t[n],d=s[n];if(!(r&&i&&c&&f&&d&&r.length===i.length&&r.length===c.length))return o(`Data length/param mismatch dataset ${n}`,"error"),NaN;for(let e=0;e<r.length;e++){0;const t=r[e],s=i[e],u=c[e];if(0===u){o(`Zero error point ${e} ds ${n}. Skipping.`,"warn");continue}if(!isFinite(s)||!isFinite(u)){o(`Non-finite y/ye point ${e} ds ${n}. Skipping.`,"warn");continue}let h=0;try{f.forEach(((e,r)=>{if(!d[r])throw new Error(`Missing params ds ${n}, pIdx ${r}.`);const a=e(d[r],[t]);if(!a||1!==a.length||!isFinite(a[0]))throw new Error(`Model ${n}-${r} invalid result x=${t}: ${JSON.stringify(a)}`);h+=a[0]}))}catch(t){return o(`Error evaluating model ds ${n}, pt ${e}: ${t.message}`,"error"),NaN}if(!isFinite(h)){o(`Non-finite model value pt ${e} ds ${n}. Skipping.`,"warn");continue}const g=(s-h)/u;l+=1===a?Math.abs(g):2===a?Math.log(1+g*g*.5):g*g}})),isFinite(l)?l:(o("Non-finite chi-squared calculated.","error"),1/0)}function s(e,t,r,n,a,i,o,s){const l=r(n),c=[],f=[],d=a.length;if(e.x.forEach(((a,o)=>{const u=e.y[o],h=e.ye[o],g=t[o],m=l[o];if(!(a&&u&&h&&g&&m&&a.length===u.length&&a.length===h.length))throw new Error(`Data length mismatch ds ${o} Jacobian.`);for(let e=0;e<a.length;e++){0;const t=a[e],l=u[e],p=h[e];if(0===p)throw new Error(`Zero error pt ${e} ds ${o} Jacobian.`);if(!isFinite(l)||!isFinite(p))throw new Error(`Non-finite y/ye pt ${e} ds ${o} Jacobian.`);let $=0;try{g.forEach(((e,r)=>{if(!m[r])throw new Error(`Missing params ds ${o}, pIdx ${r} (Jacobian orig).`);const n=e(m[r],[t]);if(!n||1!==n.length||!isFinite(n[0]))throw new Error(`Model ${o}-${r} invalid result x=${t}: ${JSON.stringify(n)}`);$+=n[0]}))}catch(t){throw s(`Error evaluating model (orig) ds ${o}, pt ${e}: ${t.message}`,"error"),t}if(!isFinite($))throw new Error(`Non-finite orig model value pt ${e} ds ${o}.`);const w=(l-$)/p;c.push(w);const y=new Array(d).fill(0);for(let a=0;a<d;a++){const l=[...n],c=l[a];let f=i*Math.abs(c)+i;0===f&&(f=i),l[a]+=f;const d=r(l);let u=0,h=!1;try{const e=d[o];g.forEach(((r,n)=>{if(h)return;if(!e||!e[n])throw new Error(`Missing params ds ${o}, pIdx ${n} (Jacobian pert).`);const a=r(e[n],[t]);if(!a||1!==a.length||!isFinite(a[0]))return s(`Model ${o}-${n} invalid result during perturbation x=${t}`,"warn"),void(h=!0);u+=a[0]}))}catch(t){s(`Error evaluating model (pert) ds ${o}, pt ${e}, actP ${a}: ${t.message}`,"error"),h=!0}if(h||!isFinite(u))s(`Non-finite/failed pert model value pt ${e}, ds ${o}, actP ${a}. Deriv=0.`,"warn"),y[a]=0;else{const e=(u-$)/f;y[a]=-e/p}isFinite(y[a])||(s(`Non-finite Jacobian element pt ${e}, ds ${o}, actP ${a}. Setting=0.`,"warn"),y[a]=0)}f.push(y)}})),c.length!==f.length)throw new Error(`Internal error: Residuals (${c.length}) != Jacobian rows (${f.length})`);if(f.length>0&&f[0].length!==d)throw new Error(`Internal error: Jacobian cols (${f[0].length}) != active params (${d})`);return{jacobian:f,residuals:c}}function l(e,t,r,n,a,i){let o=e,s=!1,l=!1;if(t){let a=null;n.forEach(((n,i)=>{t[i]&&n.forEach(((n,o)=>{if(t[i][o])for(let c=0;c<n;c++){const n=t[i]?.[o]?.[c];if(n){a||(a=JSON.parse(JSON.stringify(e)));let t=a[i][o][c];const f=t;if(void 0!==n.min&&t<n.min&&(t=n.min),void 0!==n.max&&t>n.max&&(t=n.max),t!==f){a[i][o][c]=t,l=!0;r.some((e=>e.originalCoord[0][0]===i&&e.originalCoord[0][1]===o&&e.originalCoord[1]===c))&&(s=!0)}}}}))})),a&&(o=a)}if("function"==typeof a)try{const t=l?o:e,r=l?null:JSON.stringify(t);if(o=a(t),!Array.isArray(o)||o.length!==n.length)throw new Error("Constraint function did not return a valid parameter structure.");const c=JSON.stringify(o);l||c===r?l&&c!==JSON.stringify(t)&&(s=!0,i("Custom constraint function modified parameters after box constraints.","debug")):(s=!0,i("Custom constraint function modified parameters.","debug"))}catch(t){i(`Error executing custom constraint function: ${t.message}`,"error"),o=l?JSON.parse(JSON.stringify(e)):e}return{constrainedParams:o,changedActive:s}}function c(e,t,r,n){if(!(e&&e.x&&e.y&&e.ye&&t&&r))return n("Missing data/models/params for final residual calculation.","error"),null;const a=[];let i=!1;return e.x.forEach(((o,s)=>{const l=e.y[s],c=e.ye[s],f=t[s],d=r[s],u=[];if(!(l&&c&&f&&d&&o.length===l.length&&o.length===c.length))return n(`Inconsistent data/model/params for dataset ${s} in final residual calculation. Skipping.`,"warn"),void a.push([]);for(let e=0;e<o.length;e++){const t=o[e],r=l[e],a=c[e];if(0===a||!isFinite(r)||!isFinite(a)){n(`Invalid data/error at point ${e} in dataset ${s} for final residuals. Storing NaN.`,"warn"),u.push(NaN);continue}let h=0,g=!1;try{f.forEach(((e,r)=>{if(!d[r])throw new Error(`Missing params for model ${r}.`);const n=e(d[r],[t]);if(!n||1!==n.length||!isFinite(n[0]))throw new Error(`Model ${s}-${r} returned invalid result.`);h+=n[0]}))}catch(t){n(`Error evaluating model for final residual at ds ${s}, pt ${e}: ${t.message}`,"error"),g=!0,i=!0}g||!isFinite(h)?u.push(NaN):u.push((r-h)/a)}a.push(u)})),i?null:a}function f(e,t,r,n,a){if(!e||!e.x||!t||!r||n<=1)return a("Missing data/models/params or invalid numPoints for fitted curve calculation.","error"),null;const i=[];let o=!1;return e.x.forEach(((e,s)=>{const l=t[s],c=r[s],f={x:[],y:[]};if(!l||!c||0===e.length)return a(`Inconsistent data/model/params for dataset ${s} in fitted curve calculation. Skipping.`,"warn"),void i.push(f);let d=e[0],u=e[0];for(let t=1;t<e.length;++t)e[t]<d&&(d=e[t]),e[t]>u&&(u=e[t]);if(!isFinite(d)||!isFinite(u)||u<d)return a(`Invalid X range [${d}, ${u}] for dataset ${s} in fitted curve calculation. Skipping.`,"warn"),void i.push(f);const h=u===d?0:(u-d)/(n-1);for(let e=0;e<n;e++){const t=1===n||0===h?d:d+e*h;let r=0,i=!1;try{l.forEach(((e,n)=>{if(!c[n])throw new Error(`Missing params for model ${n}.`);const a=e(c[n],[t]);if(!a||1!==a.length||!isFinite(a[0]))throw new Error(`Model ${s}-${n} returned invalid result.`);r+=a[0]}))}catch(e){a(`Error evaluating model for fitted curve at ds ${s}, x=${t}: ${e.message}`,"error"),i=!0,o=!0}f.x.push(t),f.y.push(i||!isFinite(r)?NaN:r)}i.push(f)})),o?null:i}function d(e,d,u,h={}){const g=h.maxIterations||100,m=h.errorTolerance||1e-6,p=h.gradientTolerance||1e-6,$=h.linkMap||[],w=h.fixMap||null,y=h.constraints||null,v=h.constraintFunction||null,N=h.logLevel||"info",x=n[N.toLowerCase()]??n.info,E=h.onLog&&"function"==typeof h.onLog?h.onLog:()=>{},b=h.onProgress&&"function"==typeof h.onProgress?h.onProgress:()=>{},M=h.robustCostFunction??null;let S=h.lambdaInitial||.001;const F=h.lambdaIncreaseFactor||10,P=h.lambdaDecreaseFactor||10,A=h.epsilon||1e-8,I=h.calculateFittedModel??!1,C="object"==typeof I&&I.numPoints>1?I.numPoints:300,J=!0===I||"object"==typeof I,q=(e,t)=>{x>=(n[t]??n.info)&&E(e,t)},L=e=>q(e,"info"),O=e=>q(e,"warn"),k=e=>q(e,"error"),D=e=>q(e,"debug");L("Starting lmFitGlobal...");let _=0;e&&e.x&&e.x.forEach((e=>{Array.isArray(e)?_+=e.length:O("Non-array in data.x.")})),L(`Total data points (N): ${_}`);const j={p_active:[],p_reconstructed:u,finalParamErrors:null,chiSquared:NaN,covarianceMatrix:null,parameterErrors:null,iterations:0,converged:!1,activeParamLabels:[],totalPoints:_,degreesOfFreedom:NaN,reducedChiSquared:NaN,aic:NaN,aicc:NaN,bic:NaN,residualsPerSeries:null,fittedModelCurves:null};if(0===_){const e="No data points.";return k(e),{...j,error:e}}let G;try{G=function(e,t,r,n){n("--- Running setupParameterMapping ---","debug"),n(`Received linkMap: ${JSON.stringify(t)}`,"debug"),n(`Received fixMapInput: ${JSON.stringify(r)}`,"debug");const a=[],i=[],o=[],s=r?JSON.parse(JSON.stringify(r)):[];e.forEach(((e,t)=>{a.push([]),s[t]||(s[t]=[]),e.forEach(((e,r)=>{a[t].push(e.length),s[t][r]||(s[t][r]=new Array(e.length).fill(!1)),e.forEach(((e,n)=>{i.push(e),o.push([[t,r],n]),s[t][r].length<=n&&(s[t][r][n]=!1)}))}))}));const l=i.length,c=new Array(l).fill(-1),f=new Array(l).fill(!1),d=[],u=[],h=[];o.forEach(((e,t)=>{const[[r,n],a]=e;!0===s[r]?.[n]?.[a]&&(f[t]=!0)})),n(`Initial isFixed array: ${JSON.stringify(f)}`,"debug"),(t||[]).forEach(((e,t)=>{n(`Processing Link Group ${t}: ${JSON.stringify(e)}`,"debug");let r=-1,a=null;for(const t of e){const[[e,i],s]=t,l=o.findIndex((t=>t[0][0]===e&&t[0][1]===i&&t[1]===s));if(-1!==l){if(!f[l]){r=l,a=t;break}}else n(`Coordinate ${JSON.stringify(t)} in linkMap not found.`,"warn")}if(-1===r&&e.length>0){const a=e[0],i=o.findIndex((e=>e[0][0]===a[0][0]&&e[0][1]===a[0][1]&&e[1]===a[1]));-1!==i?(r=i,n(`Link Group ${t} seems fixed, master set to flat index ${r}`,"debug"),e.forEach((e=>{const t=o.findIndex((t=>t[0][0]===e[0][0]&&t[0][1]===e[0][1]&&t[1]===e[1]));-1!==t&&t!==r&&(f[t]||(n(`Marking ${JSON.stringify(e)} as fixed due to fixed link group.`,"debug"),f[t]=!0),c[t]=r)}))):n(`Could not find fixed parameter for link group ${JSON.stringify(a)}`,"warn")}else-1!==r&&(n(`Link Group ${t} master: ${JSON.stringify(a)} (flat index ${r})`,"debug"),e.forEach((e=>{const t=o.findIndex((t=>t[0][0]===e[0][0]&&t[0][1]===e[0][1]&&t[1]===e[1]));-1!==t&&t!==r&&(f[t]&&(n(`Linking overrides fixed status for ${JSON.stringify(e)}.`,"warn"),f[t]=!1),c[t]=r,i[t]=i[r],n(`  Linked slave ${JSON.stringify(e)} (flat ${t}) to master ${r}`,"debug"))})))})),n(`Final isFixed array: ${JSON.stringify(f)}`,"debug"),n(`Final masterMap array: ${JSON.stringify(c)}`,"debug");let g=0;for(let e=0;e<l;e++)if(!f[e]&&-1===c[e]){d.push({originalCoord:o[e],flatIndex:e,activeIndex:g}),u.push(i[e]);const[[t,r],n]=o[e];h.push(`ds${t}_p${r}_v${n}`),g++}const m=u.length;return n(`Identified ${m} active parameters: ${JSON.stringify(h)}`,"debug"),n(`Active Initial Params: ${JSON.stringify(u)}`,"debug"),{activeInitialParams:u,reconstructParams:e=>{if(e.length!==m)throw new Error(`reconstructParams expects ${m} params, received ${e.length}`);const t=[...i];d.forEach(((r,n)=>{if(n>=e.length)throw new Error("Mismatch activeParamInfo/activeParams.");t[r.flatIndex]=e[n]}));for(let e=0;e<l;e++)if(-1!==c[e]){if(c[e]>=t.length)throw new Error(`Master index ${c[e]} out of bounds.`);t[e]=t[c[e]]}const r=[];let o=0;return a.forEach(((e,n)=>{r[n]=[],e.forEach(((e,a)=>{r[n][a]=[];for(let i=0;i<e;i++){if(o>=t.length)throw new Error(`Flat index ${o} out of bounds.`);r[n][a][i]=t[o],o++}}))})),o!==l&&n(`Param reconstruction mismatch: ${o} vs ${l}`,"warn"),r},activeParamInfo:d,totalActiveParams:m,paramStructure:a,activeParamLabels:h,isFixed:f,masterMap:c,paramCoordinates:o,nTotalParams:l}}(u,$,w,D)}catch(e){const t=`Parameter setup failed: ${e.message}`;return k(t),{...j,error:t}}const{activeInitialParams:R,reconstructParams:V,activeParamInfo:H,totalActiveParams:T,paramStructure:U,activeParamLabels:z}=G,K=T,{isFixed:B,masterMap:Z,paramCoordinates:X,nTotalParams:Q}=function(e,t,r){const n=[],a=[];let i=0;const o=r?JSON.parse(JSON.stringify(r)):[];e.forEach(((e,t)=>{n.push([]),o[t]||(o[t]=[]),e.forEach(((e,r)=>{n[t].push(e.length),o[t][r]||(o[t][r]=new Array(e.length).fill(!1)),e.forEach(((e,n)=>{a.push([[t,r],n]),o[t][r].length<=n&&(o[t][r][n]=!1),i++}))}))}));const s=i,l=new Array(s).fill(-1),c=new Array(s).fill(!1);return a.forEach(((e,t)=>{const[[r,n],a]=e;!0===o[r]?.[n]?.[a]&&(c[t]=!0)})),(t||[]).forEach((e=>{let t=-1;for(const r of e){const[[e,n],i]=r,o=a.findIndex((t=>t[0][0]===e&&t[0][1]===n&&t[1]===i));if(-1!==o&&!c[o]){t=o;break}}if(-1===t&&e.length>0){const r=e[0],n=a.findIndex((e=>e[0][0]===r[0][0]&&e[0][1]===r[0][1]&&e[1]===r[1]));-1!==n&&(t=n,e.forEach((e=>{const r=a.findIndex((t=>t[0][0]===e[0][0]&&t[0][1]===e[0][1]&&t[1]===e[1]));-1!==r&&r!==t&&(c[r]=!0,l[r]=t)})))}else-1!==t&&e.forEach((e=>{const r=a.findIndex((t=>t[0][0]===e[0][0]&&t[0][1]===e[0][1]&&t[1]===e[1]));-1!==r&&r!==t&&(c[r]&&(c[r]=!1),l[r]=t)}))})),{isFixed:c,masterMap:l,paramCoordinates:a,nTotalParams:s,paramStructure:n}}(u,$,w);if(0===K){O("No active parameters to fit. Calculating initial stats.");let t=NaN,r=_,n=NaN,a=NaN,i=NaN,s=NaN,l=null,u=null,h=null;const g=V([]);try{t=o(e,d,V,[],M,0,q),l=c(e,d,g,q),J&&(u=f(e,d,g,C,q)),h=g.map((e=>e.map((e=>e.map((()=>0)))))),isFinite(t)&&r>0&&(n=t/r,a=t,s=t,i=_>1?a:1/0)}catch(e){k(`Error calculating initial ChiSq/Residuals: ${e.message}`)}return{p_active:[],p_reconstructed:g,finalParamErrors:h,chiSquared:t,covarianceMatrix:[],parameterErrors:[],iterations:0,converged:!0,activeParamLabels:[],totalPoints:_,degreesOfFreedom:r,reducedChiSquared:n,aic:a,aicc:i,bic:s,error:null,residualsPerSeries:l,fittedModelCurves:u}}let W=[...R],Y=NaN;try{Y=o(e,d,V,W,M,0,q)}catch(e){const t=`Initial Chi-Squared calculation failed: ${e.message}`;return k(t),{...j,p_reconstructed:V(W),error:t}}let ee,te=!1,re=null,ne=[],ae=0,ie=null;if(L(`Total active parameters (K): ${K}`),L(`Active Parameter Labels: ${z.join(", ")}`),L(`Initial Active Parameters: ${W.map((e=>e.toExponential(3))).join(", ")}`),L(`Initial Chi-Squared: ${Y}`),!isFinite(Y)){const e="Initial Chi-Squared is not finite.";return k(e),{...j,p_reconstructed:V(W),chiSquared:Y,error:e}}for(ee=0;ee<g;ee++){let r,n,c,f;ae=ee+1,L(`--- Iteration ${ae} (Lambda: ${S.toExponential(3)}) ---`),D(`Iter ${ae} - Current Active Params: ${W.map((e=>e.toExponential(5))).join(", ")}`);try{({jacobian:r,residuals:n}=s(e,d,V,W,H,A,0,q))}catch(e){const t=`Jacobian failed: ${e.message}`;return k(`Error Jacobian/Resid iter ${ae}: ${t}`),{...j,p_reconstructed:V(W),chiSquared:Y,iterations:ae,error:t}}try{c=a(r,n),f=i(r)}catch(e){const t=`Grad/Hess failed: ${e.message}`;return k(`Error Grad/Hess iter ${ae}: ${t}`),{...j,p_reconstructed:V(W),chiSquared:Y,iterations:ae,error:t}}if(c.some((e=>!isFinite(e)))||f.some((e=>e.some((e=>!isFinite(e)))))){const e="Non-finite grad/hess.";return k(`Non-finite grad/hess iter ${ae}.`),{...j,p_reconstructed:V(W),chiSquared:Y,iterations:ae,error:e}}const u=Math.max(...c.map(Math.abs));if(u<p){L(`Converged (grad tol ${p}). Max Grad: ${u.toExponential(3)}`),te=!0;break}let h;L(`Gradient: ${c.map((e=>e.toExponential(3))).join(", ")}`);let g=!1,$=0;const w=5;let N=S;for(;!g&&$<w;){const e=f.map(((e,t)=>e.map(((e,r)=>t===r?e+N:e))));try{const r=c.map((e=>-e));if(h=t(e,r),h.some((e=>!isFinite(e))))throw new Error("NaN/Inf in updates.");g=!0}catch(e){if($++,O(`Solve failed (Att ${$}/${w}, Iter ${ae}): ${e.message}. Inc lambda.`),N=Math.min(N*F*($>1?F:1),1e10),L(`Attempting solve with Lambda: ${N.toExponential(3)}`),$>=w){const e="Failed solve.";return k(`Failed solve after ${w} attempts.`),{...j,p_reconstructed:V(W),chiSquared:Y,iterations:ae,error:e}}}}if(!g)continue;S=N,L(`Parameter Updates: ${h.map((e=>e.toExponential(3))).join(", ")}`);const x=W.map(((e,t)=>e+h[t]));let E=V(x);const{constrainedParams:I,changedActive:C}=l(E,y,H,U,v,q);E=I;let J=[...x];if(C){const e=[];H.forEach((t=>{const[[r,n],a]=t.originalCoord;e.push(E[r][n][a])})),J=e,L("Constraints modified parameters.")}let _=NaN;try{_=o(e,d,V,J,M,0,q)}catch(e){k(`Error ChiSq proposed step iter ${ae}: ${e.message}`),_=1/0}if(L(`New Chi-Squared: ${_}`),isFinite(_)&&_<Y){const e=Y-_;W=J,Y=_,S=Math.max(S/P,1e-12),L(`Accepted. ChiSq decreased by ${e.toExponential(3)}. Lambda decreased to: ${S.toExponential(3)}`);try{b({iteration:ae,chiSquared:Y,lambda:S,activeParameters:[...W]})}catch(e){O(`Error in onProgress callback: ${e.message}`)}if(e<m){L(`Converged (chiSq tol ${m}).`),te=!0;break}}else S=Math.min(S*F,1e10),L(`Rejected (ChiSq ${isNaN(_)?"NaN":"increased/stagnant"}). Lambda increased to: ${S.toExponential(3)}`),S>=1e10&&O("Lambda reached maximum limit.")}te||ee!==g||O(`lmFitGlobal did not converge within ${g} iterations.`),L("Recalculating final Jacobian/Hessian for covariance...");try{const{jacobian:t}=s(e,d,V,W,H,A,0,q);ie=i(t)}catch(e){k(`Failed to recalculate final Hessian: ${e.message}`),ie=null}let oe=NaN,se=NaN,le=NaN,ce=NaN,fe=NaN;if(isFinite(Y)&&_>0)if(oe=_-K,oe>0){se=Y/oe,le=Y+2*K;const e=_-K-1;e>0?ce=le+2*K*(K+1)/e:(ce=1/0,O("AICc denominator (N-K-1) is zero or negative.")),fe=Y+K*Math.log(_)}else O("Degrees of freedom is zero or negative."),le=Y+2*K,fe=Y+K*Math.log(_),ce=1/0;else O("Final Chi-Squared is not finite. Cannot calculate statistics.");if(ne=new Array(K).fill(NaN),ie&&K>0)try{re=r(ie),ne=re.map(((e,t)=>{const r=e[t]*(se||1);return isFinite(r)?Math.sqrt(Math.abs(r)):NaN})),ne.some(isNaN)&&O("NaN encountered in parameter errors.")}catch(e){k(`Failed to calculate covariance matrix/parameter errors: ${e.message}`),re=new Array(K).fill(0).map((()=>new Array(K).fill(NaN))),ne=new Array(K).fill(NaN)}else K>0&&O("Could not calculate covariance matrix (no valid final Hessian?)."),re=new Array(K).fill(0).map((()=>new Array(K).fill(NaN)));const de=V(W);let ue=null;try{ue=[];let e=0;U.forEach(((t,r)=>{ue[r]=[],t.forEach(((t,n)=>{ue[r][n]=[];for(let a=0;a<t;a++){let t=NaN;if(B[e])t=0;else if(-1!==Z[e]){const r=Z[e],n=H.find((e=>e.flatIndex===r));t=n?ne[n.activeIndex]:0}else{const r=H.find((t=>t.flatIndex===e));r?t=ne[r.activeIndex]:O(`Could not find active info for supposedly active parameter at flat index ${e}`)}ue[r][n][a]=t,e++}}))}))}catch(e){k(`Error constructing finalParamErrors structure: ${e.message}`),ue=null}let he=null;try{he=c(e,d,de,q)}catch(e){k(`Failed to calculate final residuals: ${e.message}`)}let ge=null;if(J){L(`Calculating fitted model curves with ${C} points...`);try{ge=f(e,d,de,C,q)}catch(e){k(`Failed to calculate fitted model curves: ${e.message}`)}}return L("--------------------"),L("lmFitGlobal Finished."),L(`Iterations Performed: ${ae}`),L(`Total Points (N): ${_}`),L(`Active Parameters (K): ${K}`),L(`Degrees of Freedom (N-K): ${oe}`),L(`Final Active Parameters: ${W.map((e=>e.toExponential(5))).join(", ")}`),L(`Final Chi-Squared: ${Y}`),L(`Reduced Chi-Squared: ${se}`),L(`AIC: ${le}`),L(`AICc: ${ce}`),L(`BIC: ${fe}`),L(`Parameter Errors (Active): ${ne.map((e=>isNaN(e)?"NaN":e.toExponential(3))).join(", ")}`),L(`Converged: ${te}`),L("--------------------"),{p_active:W,p_reconstructed:de,finalParamErrors:ue,chiSquared:Y,covarianceMatrix:re,parameterErrors:ne,iterations:ae,converged:te,activeParamLabels:z,error:null,totalPoints:_,degreesOfFreedom:oe,reducedChiSquared:se,aic:le,aicc:ce,bic:fe,residualsPerSeries:he,fittedModelCurves:ge}}function u(e){return e&&Array.isArray(e.x)&&(0===e.x.length||!Array.isArray(e.x[0]))}function h(e,t,r,n){const a={x:[e.x],y:[e.y],ye:[e.ye]},i=[Array.isArray(t)?t:[t]],o=[r],s={...n};return n.fixMap&&!Array.isArray(n.fixMap[0])&&(s.fixMap=[n.fixMap]),n.constraints&&!Array.isArray(n.constraints[0])&&(s.constraints=[n.constraints]),delete s.linkMap,{data:a,modelFunction:i,initialParameters:o,options:s}}function g(e,t,r,n={}){if(!u(e))throw new Error("lmFit requires single dataset input format (e.g., data.x as a 1D array). Use lmFitGlobal or lmFitIndependent for multiple datasets.");const a=Array.isArray(t)?t:[t],i=1!==a.length||Array.isArray(r[0])?r:[r],{data:o,modelFunction:s,initialParameters:l,options:c}=h(e,a,i,n);return d(o,s,l,c)}e.lmFitGlobal=d,e.lmFit=g,e.lmFitIndependent=function(e,t,r,n={}){if(u(e)){console.warn("lmFitIndependent received single dataset input. Calling lmFit instead.");try{const a=Array.isArray(t)?t:[t],i=1!==a.length||Array.isArray(r[0])?r[0]:r,o=(a.length,a[0]);return[g(e,o,i,n)]}catch(e){return[{error:`Error processing single dataset input for lmFitIndependent: ${e.message}`,converged:!1}]}}const a=e.x.length;if(0===a)return[];const i=[],o=n.onLog||(()=>{}),s=n.onProgress||(()=>{});for(let l=0;l<a;l++){const a=l;console.log(`--- Starting Independent Fit for Dataset ${a} ---`);const c={x:e.x[l],y:e.y[l],ye:e.ye[l]},f=t[l],u=r[l],g={...n};n.fixMap&&(g.fixMap=n.fixMap[l]),n.constraints&&(g.constraints=n.constraints[l]),delete g.linkMap,delete g.onLog,delete g.onProgress,g.onLog=(e,t)=>{o(e,t,a)},g.onProgress=e=>{s(e,a)};const{data:m,modelFunction:p,initialParameters:$,options:w}=h(c,f,u,g);try{const e=d(m,p,$,w);i.push(e)}catch(e){console.error(`Error fitting dataset ${a}:`,e),o(`Fit failed for dataset ${a}: ${e.message}`,"error",a),i.push({error:`Fit failed: ${e.message}`,converged:!1,p_active:[],p_reconstructed:u,finalParamErrors:null,chiSquared:NaN,covarianceMatrix:null,parameterErrors:[],iterations:0,activeParamLabels:[],totalPoints:c.x?.length??0,degreesOfFreedom:NaN,reducedChiSquared:NaN,aic:NaN,aicc:NaN,bic:NaN,residualsPerSeries:null,fittedModelCurves:null})}console.log(`--- Finished Independent Fit for Dataset ${a} ---`)}return i}}("undefined"!=typeof window?window:global);
//# sourceMappingURL=globalfit.min.js.map